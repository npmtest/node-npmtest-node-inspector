{"/home/travis/build/npmtest/node-npmtest-node-inspector/test.js":"/* istanbul instrument in package npmtest_node_inspector */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-node-inspector/lib.npmtest_node_inspector.js":"/* istanbul instrument in package npmtest_node_inspector */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_node_inspector = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_node_inspector = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-node-inspector/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-node-inspector && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_node_inspector */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_node_inspector\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_node_inspector.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_node_inspector.rollup.js'] =\n            local.assetsDict['/assets.npmtest_node_inspector.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_node_inspector.__dirname + '/lib.npmtest_node_inspector.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-node-inspector/node_modules/node-inspector/index.js":"// Public API for node-inspector embedders\nvar url = require('url');\nvar path = require('path');\n\nexports.buildInspectorUrl = buildInspectorUrl;\nexports.buildWebSocketUrl = buildWebSocketUrl;\n\n/**\n * Build a URL for loading inspector UI in the browser.\n * @param {string|undefined} inspectorHost as configured via --web-host\n * @param {number} inspectorPort as configured via --web-port\n * @param {number} debugPort as configured via --debug in the debugged app\n * @param {number} isHttps as configured via --ssl-cert and --ssl-key in the debugged app\n */\nfunction buildInspectorUrl(inspectorHost, inspectorPort, debugPort, isHttps) {\n  var host = inspectorHost == '0.0.0.0' ? '127.0.0.1' : inspectorHost;\n  var port = inspectorPort;\n  var protocol = isHttps ? 'https' : 'http';\n\n  var isUnixSocket = !/^\\d+$/.test(port);\n  if (isUnixSocket) {\n    host = path.resolve(__dirname, inspectorPort);\n    port = null;\n    protocol = 'unix';\n  }\n\n  var parts = {\n    protocol: protocol,\n    hostname: host,\n    port: port,\n    pathname: '/',\n    search: '?port=' + debugPort\n  };\n\n  return url.format(parts);\n}\n\n/**\n * Build a URL for the WebSocket endpoint.\n * @param {string|undefined} inspectorHost as configured via --web-host\n * @param {number} inspectorPort as configured via --web-port\n * @param {number} debugPort as configured via --debug in the debugged app\n * @param {number} isHttps as configured via --ssl-cert and --ssl-key in the debugged app\n */\nfunction buildWebSocketUrl(inspectorHost, inspectorPort, debugPort, isSecure) {\n  var parts = {\n    protocol: isSecure ? 'wss:' : 'ws:',\n    hostname: inspectorHost == '0.0.0.0' ? '127.0.0.1' : inspectorHost,\n    port: inspectorPort,\n    pathname: '/',\n    search: '?port=' + debugPort,\n    slashes: true\n  };\n\n  return url.format(parts);\n}\n","/home/travis/build/npmtest/node-npmtest-node-inspector/node_modules/node-inspector/front-end/Runtime.js":"/*\n * Copyright (C) 2014 Google Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n// This gets all concatenated module descriptors in the release mode.\nvar allDescriptors = [];\nvar applicationDescriptor;\nvar _loadedScripts = {};\n\n/**\n * @param {string} url\n * @return {!Promise.<string>}\n */\nfunction loadResourcePromise(url)\n{\n    return new Promise(load);\n\n    /**\n     * @param {function(?)} fulfill\n     * @param {function(*)} reject\n     */\n    function load(fulfill, reject)\n    {\n        var xhr = new XMLHttpRequest();\n        xhr.open(\"GET\", url, true);\n        xhr.onreadystatechange = onreadystatechange;\n\n        /**\n         * @param {Event} e\n         */\n        function onreadystatechange(e)\n        {\n            if (xhr.readyState !== 4)\n                return;\n\n            if ([0, 200, 304].indexOf(xhr.status) === -1)  // Testing harness file:/// results in 0.\n                reject(new Error(\"While loading from url \" + url + \" server responded with a status of \" + xhr.status));\n            else\n                fulfill(e.target.response);\n        }\n        xhr.send(null);\n    }\n}\n\n/**\n * http://tools.ietf.org/html/rfc3986#section-5.2.4\n * @param {string} path\n * @return {string}\n */\nfunction normalizePath(path)\n{\n    if (path.indexOf(\"..\") === -1 && path.indexOf('.') === -1)\n        return path;\n\n    var normalizedSegments = [];\n    var segments = path.split(\"/\");\n    for (var i = 0; i < segments.length; i++) {\n        var segment = segments[i];\n        if (segment === \".\")\n            continue;\n        else if (segment === \"..\")\n            normalizedSegments.pop();\n        else if (segment)\n            normalizedSegments.push(segment);\n    }\n    var normalizedPath = normalizedSegments.join(\"/\");\n    if (normalizedPath[normalizedPath.length - 1] === \"/\")\n        return normalizedPath;\n    if (path[0] === \"/\" && normalizedPath)\n        normalizedPath = \"/\" + normalizedPath;\n    if ((path[path.length - 1] === \"/\") || (segments[segments.length - 1] === \".\") || (segments[segments.length - 1] === \"..\"))\n        normalizedPath = normalizedPath + \"/\";\n\n    return normalizedPath;\n}\n\n/**\n * @param {!Array.<string>} scriptNames\n * @return {!Promise.<undefined>}\n */\nfunction loadScriptsPromise(scriptNames)\n{\n    /** @type {!Array.<!Promise.<string>>} */\n    var promises = [];\n    /** @type {!Array.<string>} */\n    var urls = [];\n    var sources = new Array(scriptNames.length);\n    var scriptToEval = 0;\n    for (var i = 0; i < scriptNames.length; ++i) {\n        var scriptName = scriptNames[i];\n        var sourceURL = self._importScriptPathPrefix + scriptName;\n        var schemaIndex = sourceURL.indexOf(\"://\") + 3;\n        sourceURL = sourceURL.substring(0, schemaIndex) + normalizePath(sourceURL.substring(schemaIndex));\n        if (_loadedScripts[sourceURL])\n            continue;\n        urls.push(sourceURL);\n        promises.push(loadResourcePromise(sourceURL).then(scriptSourceLoaded.bind(null, i), scriptSourceLoaded.bind(null, i, undefined)));\n    }\n    return Promise.all(promises).then(undefined);\n\n    /**\n     * @param {number} scriptNumber\n     * @param {string=} scriptSource\n     */\n    function scriptSourceLoaded(scriptNumber, scriptSource)\n    {\n        sources[scriptNumber] = scriptSource || \"\";\n        // Eval scripts as fast as possible.\n        while (typeof sources[scriptToEval] !== \"undefined\") {\n            evaluateScript(urls[scriptToEval], sources[scriptToEval]);\n            ++scriptToEval;\n        }\n    }\n\n    /**\n     * @param {string} sourceURL\n     * @param {string=} scriptSource\n     */\n    function evaluateScript(sourceURL, scriptSource)\n    {\n        _loadedScripts[sourceURL] = true;\n        if (!scriptSource) {\n            // Do not reject, as this is normal in the hosted mode.\n            console.error(\"Empty response arrived for script '\" + sourceURL + \"'\");\n            return;\n        }\n        self.eval(scriptSource + \"\\n//# sourceURL=\" + sourceURL);\n    }\n}\n\n(function() {\n    var baseUrl = self.location ? self.location.origin + self.location.pathname : \"\";\n    self._importScriptPathPrefix = baseUrl.substring(0, baseUrl.lastIndexOf(\"/\") + 1);\n})();\n\n/**\n * @constructor\n * @param {!Array.<!Runtime.ModuleDescriptor>} descriptors\n * @param {!Array.<string>=} coreModuleNames\n */\nfunction Runtime(descriptors, coreModuleNames)\n{\n    /**\n     * @type {!Array.<!Runtime.Module>}\n     */\n    this._modules = [];\n    /**\n     * @type {!Object.<string, !Runtime.Module>}\n     */\n    this._modulesMap = {};\n    /**\n     * @type {!Array.<!Runtime.Extension>}\n     */\n    this._extensions = [];\n\n    /**\n     * @type {!Object.<string, !function(new:Object)>}\n     */\n    this._cachedTypeClasses = {};\n\n    /**\n     * @type {!Object.<string, !Runtime.ModuleDescriptor>}\n     */\n    this._descriptorsMap = {};\n\n    for (var i = 0; i < descriptors.length; ++i)\n        this._registerModule(descriptors[i]);\n    if (coreModuleNames)\n        this._loadAutoStartModules(coreModuleNames).catch(Runtime._reportError);\n}\n\n/**\n * @type {!Object.<string, string>}\n */\nRuntime._queryParamsObject = { __proto__: null };\n\n/**\n * @type {!Object.<string, string>}\n */\nRuntime.cachedResources = { __proto__: null };\n\n/**\n * @return {boolean}\n */\nRuntime.isReleaseMode = function()\n{\n    return !!allDescriptors.length;\n}\n\n/**\n * @param {string} appName\n */\nRuntime.startApplication = function(appName)\n{\n    console.timeStamp(\"Runtime.startApplication\");\n\n    var allDescriptorsByName = {};\n    for (var i = 0; Runtime.isReleaseMode() && i < allDescriptors.length; ++i) {\n        var d = allDescriptors[i];\n        allDescriptorsByName[d[\"name\"]] = d;\n    }\n\n    var applicationPromise;\n    if (applicationDescriptor)\n        applicationPromise = Promise.resolve(applicationDescriptor);\n    else\n        applicationPromise = loadResourcePromise(appName + \".json\").then(JSON.parse.bind(JSON));\n\n    applicationPromise.then(parseModuleDescriptors);\n\n    /**\n     * @param {!Array.<!Object>} configuration\n     */\n    function parseModuleDescriptors(configuration)\n    {\n        var moduleJSONPromises = [];\n        var coreModuleNames = [];\n        for (var i = 0; i < configuration.length; ++i) {\n            var descriptor = configuration[i];\n            if (descriptor[\"type\"] === \"worker\")\n                continue;\n            var name = descriptor[\"name\"];\n            var moduleJSON = allDescriptorsByName[name];\n            if (moduleJSON)\n                moduleJSONPromises.push(Promise.resolve(moduleJSON));\n            else\n                moduleJSONPromises.push(loadResourcePromise(name + \"/module.json\").then(JSON.parse.bind(JSON)));\n            if (descriptor[\"type\"] === \"autostart\")\n                coreModuleNames.push(name);\n        }\n\n        Promise.all(moduleJSONPromises).then(instantiateRuntime).catch(Runtime._reportError);\n        /**\n         * @param {!Array.<!Object>} moduleDescriptors\n         */\n        function instantiateRuntime(moduleDescriptors)\n        {\n            for (var i = 0; !Runtime.isReleaseMode() && i < moduleDescriptors.length; ++i)\n                moduleDescriptors[i][\"name\"] = configuration[i][\"name\"];\n            self.runtime = new Runtime(moduleDescriptors, coreModuleNames);\n        }\n    }\n}\n\n/**\n * @param {string} name\n * @return {?string}\n */\nRuntime.queryParam = function(name)\n{\n    return Runtime._queryParamsObject[name] || null;\n}\n\n/**\n * @param {!Array.<string>} banned\n * @return {string}\n */\nRuntime.constructQueryParams = function(banned)\n{\n    var params = [];\n    for (var key in Runtime._queryParamsObject) {\n        if (!key || banned.indexOf(key) !== -1)\n            continue;\n        params.push(key + \"=\" + Runtime._queryParamsObject[key]);\n    }\n    return params.length ? \"?\" + params.join(\"&\") : \"\";\n}\n\n/**\n * @return {!Object}\n */\nRuntime._experimentsSetting = function()\n{\n    try {\n        return /** @type {!Object} */ (JSON.parse(self.localStorage && self.localStorage[\"experiments\"] ? self.localStorage[\"experiments\"] : \"{}\"));\n    } catch (e) {\n        console.error(\"Failed to parse localStorage['experiments']\");\n        return {};\n    }\n}\n\n/**\n * @param {!Array.<!Promise.<T, !Error>>} promises\n * @return {!Promise.<!Array.<T>>}\n * @template T\n */\nRuntime._some = function(promises)\n{\n    var all = [];\n    var wasRejected = [];\n    for (var i = 0; i < promises.length; ++i) {\n        // Workaround closure compiler bug.\n        var handlerFunction = /** @type {function()} */ (handler.bind(promises[i], i));\n        all.push(promises[i].catch(handlerFunction));\n    }\n\n    return Promise.all(all).then(filterOutFailuresResults);\n\n    /**\n     * @param {!Array.<T>} results\n     * @return {!Array.<T>}\n     * @template T\n     */\n    function filterOutFailuresResults(results)\n    {\n        var filtered = [];\n        for (var i = 0; i < results.length; ++i) {\n            if (!wasRejected[i])\n                filtered.push(results[i]);\n        }\n        return filtered;\n    }\n\n    /**\n     * @this {!Promise}\n     * @param {number} index\n     * @param {!Error} e\n     */\n    function handler(index, e)\n    {\n        wasRejected[index] = true;\n        console.error(e.stack);\n    }\n}\n\nRuntime._console = console;\nRuntime._originalAssert = console.assert;\nRuntime._assert = function(value, message)\n{\n    if (value)\n        return;\n    Runtime._originalAssert.call(Runtime._console, value, message);\n}\n\n/**\n * @param {*} e\n */\nRuntime._reportError = function(e)\n{\n    if (e instanceof Error)\n        console.error(e.stack);\n    else\n        console.error(e);\n}\n\nRuntime.prototype = {\n\n    /**\n     * @param {!Runtime.ModuleDescriptor} descriptor\n     */\n    _registerModule: function(descriptor)\n    {\n        var module = new Runtime.Module(this, descriptor);\n        this._modules.push(module);\n        this._modulesMap[descriptor[\"name\"]] = module;\n    },\n\n    /**\n     * @param {string} moduleName\n     * @return {!Promise.<undefined>}\n     */\n    loadModulePromise: function(moduleName)\n    {\n        return this._modulesMap[moduleName]._loadPromise();\n    },\n\n    /**\n     * @param {!Array.<string>} moduleNames\n     * @return {!Promise.<!Array.<*>>}\n     */\n    _loadAutoStartModules: function(moduleNames)\n    {\n        var promises = [];\n        for (var i = 0; i < moduleNames.length; ++i) {\n            if (Runtime.isReleaseMode())\n                this._modulesMap[moduleNames[i]]._loaded = true;\n            else\n                promises.push(this.loadModulePromise(moduleNames[i]));\n        }\n        return Promise.all(promises);\n    },\n\n    /**\n     * @param {!Runtime.Extension} extension\n     * @param {?function(function(new:Object)):boolean} predicate\n     * @return {boolean}\n     */\n    _checkExtensionApplicability: function(extension, predicate)\n    {\n        if (!predicate)\n            return false;\n        var contextTypes = /** @type {!Array.<string>|undefined} */ (extension.descriptor().contextTypes);\n        if (!contextTypes)\n            return true;\n        for (var i = 0; i < contextTypes.length; ++i) {\n            var contextType = this._resolve(contextTypes[i]);\n            var isMatching = !!contextType && predicate(contextType);\n            if (isMatching)\n                return true;\n        }\n        return false;\n    },\n\n    /**\n     * @param {!Runtime.Extension} extension\n     * @param {?Object} context\n     * @return {boolean}\n     */\n    isExtensionApplicableToContext: function(extension, context)\n    {\n        if (!context)\n            return true;\n        return this._checkExtensionApplicability(extension, isInstanceOf);\n\n        /**\n         * @param {!Function} targetType\n         * @return {boolean}\n         */\n        function isInstanceOf(targetType)\n        {\n            return context instanceof targetType;\n        }\n    },\n\n    /**\n     * @param {!Runtime.Extension} extension\n     * @param {!Set.<!Function>=} currentContextTypes\n     * @return {boolean}\n     */\n    isExtensionApplicableToContextTypes: function(extension, currentContextTypes)\n    {\n        if (!extension.descriptor().contextTypes)\n            return true;\n\n        return this._checkExtensionApplicability(extension, currentContextTypes ? isContextTypeKnown : null);\n\n        /**\n         * @param {!Function} targetType\n         * @return {boolean}\n         */\n        function isContextTypeKnown(targetType)\n        {\n            return currentContextTypes.has(targetType);\n        }\n    },\n\n    /**\n     * @param {*} type\n     * @param {?Object=} context\n     * @return {!Array.<!Runtime.Extension>}\n     */\n    extensions: function(type, context)\n    {\n        return this._extensions.filter(filter).sort(orderComparator);\n\n        /**\n         * @param {!Runtime.Extension} extension\n         * @return {boolean}\n         */\n        function filter(extension)\n        {\n            if (extension._type !== type && extension._typeClass() !== type)\n                return false;\n            var activatorExperiment = extension.descriptor()[\"experiment\"];\n            if (activatorExperiment && !Runtime.experiments.isEnabled(activatorExperiment))\n                return false;\n            activatorExperiment = extension._module._descriptor[\"experiment\"];\n            if (activatorExperiment && !Runtime.experiments.isEnabled(activatorExperiment))\n                return false;\n            return !context || extension.isApplicable(context);\n        }\n\n        /**\n         * @param {!Runtime.Extension} extension1\n         * @param {!Runtime.Extension} extension2\n         * @return {number}\n         */\n        function orderComparator(extension1, extension2)\n        {\n            var order1 = extension1.descriptor()[\"order\"] || 0;\n            var order2 = extension2.descriptor()[\"order\"] || 0;\n            return order1 - order2;\n        }\n    },\n\n    /**\n     * @param {*} type\n     * @param {?Object=} context\n     * @return {?Runtime.Extension}\n     */\n    extension: function(type, context)\n    {\n        return this.extensions(type, context)[0] || null;\n    },\n\n    /**\n     * @param {*} type\n     * @param {?Object=} context\n     * @return {!Promise.<!Array.<!Object>>}\n     */\n    instancesPromise: function(type, context)\n    {\n        var extensions = this.extensions(type, context);\n        var promises = [];\n        for (var i = 0; i < extensions.length; ++i)\n            promises.push(extensions[i].instancePromise());\n        return Runtime._some(promises);\n    },\n\n    /**\n     * @param {*} type\n     * @param {?Object=} context\n     * @return {!Promise.<!Object>}\n     */\n    instancePromise: function(type, context)\n    {\n        var extension = this.extension(type, context);\n        if (!extension)\n            return Promise.reject(new Error(\"No such extension: \" + type + \" in given context.\"));\n        return extension.instancePromise();\n    },\n\n    /**\n     * @return {?function(new:Object)}\n     */\n    _resolve: function(typeName)\n    {\n        if (!this._cachedTypeClasses[typeName]) {\n            var path = typeName.split(\".\");\n            var object = window;\n            for (var i = 0; object && (i < path.length); ++i)\n                object = object[path[i]];\n            if (object)\n                this._cachedTypeClasses[typeName] = /** @type function(new:Object) */(object);\n        }\n        return this._cachedTypeClasses[typeName] || null;\n    }\n}\n\n/**\n * @constructor\n */\nRuntime.ModuleDescriptor = function()\n{\n    /**\n     * @type {string}\n     */\n    this.name;\n\n    /**\n     * @type {!Array.<!Runtime.ExtensionDescriptor>}\n     */\n    this.extensions;\n\n    /**\n     * @type {!Array.<string>|undefined}\n     */\n    this.dependencies;\n\n    /**\n     * @type {!Array.<string>}\n     */\n    this.scripts;\n}\n\n/**\n * @constructor\n */\nRuntime.ExtensionDescriptor = function()\n{\n    /**\n     * @type {string}\n     */\n    this.type;\n\n    /**\n     * @type {string|undefined}\n     */\n    this.className;\n\n    /**\n     * @type {!Array.<string>|undefined}\n     */\n    this.contextTypes;\n}\n\n/**\n * @constructor\n * @param {!Runtime} manager\n * @param {!Runtime.ModuleDescriptor} descriptor\n */\nRuntime.Module = function(manager, descriptor)\n{\n    this._manager = manager;\n    this._descriptor = descriptor;\n    this._name = descriptor.name;\n    /** @type {!Object.<string, ?Object>} */\n    this._instanceMap = {};\n    var extensions = /** @type {?Array.<!Runtime.ExtensionDescriptor>} */ (descriptor.extensions);\n    for (var i = 0; extensions && i < extensions.length; ++i)\n        this._manager._extensions.push(new Runtime.Extension(this, extensions[i]));\n    this._loaded = false;\n}\n\nRuntime.Module.prototype = {\n    /**\n     * @return {string}\n     */\n    name: function()\n    {\n        return this._name;\n    },\n\n    /**\n     * @return {!Promise.<undefined>}\n     */\n    _loadPromise: function()\n    {\n        if (this._loaded)\n            return Promise.resolve();\n\n        if (this._pendingLoadPromise)\n            return this._pendingLoadPromise;\n\n        var dependencies = this._descriptor.dependencies;\n        var dependencyPromises = [];\n        for (var i = 0; dependencies && i < dependencies.length; ++i)\n            dependencyPromises.push(this._manager._modulesMap[dependencies[i]]._loadPromise());\n\n        this._pendingLoadPromise = Promise.all(dependencyPromises)\n            .then(this._loadStylesheets.bind(this))\n            .then(this._loadScripts.bind(this))\n            .then(markAsLoaded.bind(this));\n\n        return this._pendingLoadPromise;\n\n        /**\n         * @this {Runtime.Module}\n         */\n        function markAsLoaded()\n        {\n            delete this._pendingLoadPromise;\n            this._loaded = true;\n        }\n    },\n\n    /**\n     * @return {!Promise.<undefined>}\n     * @this {Runtime.Module}\n     */\n    _loadStylesheets: function()\n    {\n        var stylesheets = this._descriptor[\"stylesheets\"];\n        if (!stylesheets)\n            return Promise.resolve();\n        var promises = [];\n        for (var i = 0; i < stylesheets.length; ++i) {\n            var url = this._modularizeURL(stylesheets[i]);\n            promises.push(loadResourcePromise(url).then(cacheStylesheet.bind(this, url), cacheStylesheet.bind(this, url, undefined)));\n        }\n        return Promise.all(promises).then(undefined);\n\n        /**\n         * @param {string} path\n         * @param {string=} content\n         */\n        function cacheStylesheet(path, content)\n        {\n            if (!content) {\n                console.error(\"Failed to load stylesheet: \" + path);\n                return;\n            }\n            var sourceURL = window.location.href;\n            if (window.location.search)\n                sourceURL.replace(window.location.search, \"\");\n            sourceURL = sourceURL.substring(0, sourceURL.lastIndexOf(\"/\") + 1) + path;\n            Runtime.cachedResources[path] = content + \"\\n/*# sourceURL=\" + sourceURL + \" */\";\n        }\n    },\n\n    /**\n     * @return {!Promise.<undefined>}\n     */\n    _loadScripts: function()\n    {\n        if (!this._descriptor.scripts)\n            return Promise.resolve();\n\n        if (Runtime.isReleaseMode())\n            return loadScriptsPromise([this._name + \"_module.js\"]);\n\n        return loadScriptsPromise(this._descriptor.scripts.map(this._modularizeURL, this)).catch(Runtime._reportError);\n    },\n\n    /**\n     * @param {string} resourceName\n     */\n    _modularizeURL: function(resourceName)\n    {\n        return normalizePath(this._name + \"/\" + resourceName);\n    },\n\n    /**\n     * @param {string} className\n     * @return {?Object}\n     */\n    _instance: function(className)\n    {\n        if (className in this._instanceMap)\n            return this._instanceMap[className];\n\n        var constructorFunction = window.eval(className);\n        if (!(constructorFunction instanceof Function)) {\n            this._instanceMap[className] = null;\n            return null;\n        }\n\n        var instance = new constructorFunction();\n        this._instanceMap[className] = instance;\n        return instance;\n    }\n}\n\n/**\n * @constructor\n * @param {!Runtime.Module} module\n * @param {!Runtime.ExtensionDescriptor} descriptor\n */\nRuntime.Extension = function(module, descriptor)\n{\n    this._module = module;\n    this._descriptor = descriptor;\n\n    this._type = descriptor.type;\n    this._hasTypeClass = this._type.charAt(0) === \"@\";\n\n    /**\n     * @type {?string}\n     */\n    this._className = descriptor.className || null;\n}\n\nRuntime.Extension.prototype = {\n    /**\n     * @return {!Object}\n     */\n    descriptor: function()\n    {\n        return this._descriptor;\n    },\n\n    /**\n     * @return {!Runtime.Module}\n     */\n    module: function()\n    {\n        return this._module;\n    },\n\n    /**\n     * @return {?function(new:Object)}\n     */\n    _typeClass: function()\n    {\n        if (!this._hasTypeClass)\n            return null;\n        return this._module._manager._resolve(this._type.substring(1));\n    },\n\n    /**\n     * @param {?Object} context\n     * @return {boolean}\n     */\n    isApplicable: function(context)\n    {\n        return this._module._manager.isExtensionApplicableToContext(this, context);\n    },\n\n    /**\n     * @return {!Promise.<!Object>}\n     */\n    instancePromise: function()\n    {\n        if (!this._className)\n            return Promise.reject(new Error(\"No class name in extension\"));\n        var className = this._className;\n        if (this._instance)\n            return Promise.resolve(this._instance);\n\n        return this._module._loadPromise().then(constructInstance.bind(this));\n\n        /**\n         * @return {!Object}\n         * @this {Runtime.Extension}\n         */\n        function constructInstance()\n        {\n            var result = this._module._instance(className);\n            if (!result)\n                return Promise.reject(\"Could not instantiate: \" + className);\n            return result;\n        }\n    }\n}\n\n/**\n * @constructor\n */\nRuntime.ExperimentsSupport = function()\n{\n    this._supportEnabled = Runtime.queryParam(\"experiments\") !== null;\n    this._experiments = [];\n    this._experimentNames = {};\n    this._enabledTransiently = {};\n}\n\nRuntime.ExperimentsSupport.prototype = {\n    /**\n     * @return {!Array.<!Runtime.Experiment>}\n     */\n    allConfigurableExperiments: function()\n    {\n        var result = [];\n        for (var i = 0; i < this._experiments.length; i++) {\n            var experiment = this._experiments[i];\n            if (!this._enabledTransiently[experiment.name])\n                result.push(experiment);\n        }\n        return result;\n    },\n\n    /**\n     * @return {boolean}\n     */\n    supportEnabled: function()\n    {\n        return this._supportEnabled;\n    },\n\n    /**\n     * @param {!Object} value\n     */\n    _setExperimentsSetting: function(value)\n    {\n        if (!self.localStorage)\n            return;\n        self.localStorage[\"experiments\"] = JSON.stringify(value);\n    },\n\n    /**\n     * @param {string} experimentName\n     * @param {string} experimentTitle\n     * @param {boolean=} hidden\n     */\n    register: function(experimentName, experimentTitle, hidden)\n    {\n        Runtime._assert(!this._experimentNames[experimentName], \"Duplicate registration of experiment \" + experimentName);\n        this._experimentNames[experimentName] = true;\n        this._experiments.push(new Runtime.Experiment(this, experimentName, experimentTitle, !!hidden));\n    },\n\n    /**\n     * @param {string} experimentName\n     * @return {boolean}\n     */\n    isEnabled: function(experimentName)\n    {\n        this._checkExperiment(experimentName);\n\n        if (this._enabledTransiently[experimentName])\n            return true;\n        if (!this.supportEnabled())\n            return false;\n\n        return !!Runtime._experimentsSetting()[experimentName];\n    },\n\n    /**\n     * @param {string} experimentName\n     * @param {boolean} enabled\n     */\n    setEnabled: function(experimentName, enabled)\n    {\n        this._checkExperiment(experimentName);\n        var experimentsSetting = Runtime._experimentsSetting();\n        experimentsSetting[experimentName] = enabled;\n        this._setExperimentsSetting(experimentsSetting);\n    },\n\n    /**\n     * @param {!Array.<string>} experimentNames\n     */\n    setDefaultExperiments: function(experimentNames)\n    {\n        for (var i = 0; i < experimentNames.length; ++i) {\n            this._checkExperiment(experimentNames[i]);\n            this._enabledTransiently[experimentNames[i]] = true;\n        }\n    },\n\n    /**\n     * @param {string} experimentName\n     */\n    enableForTest: function(experimentName)\n    {\n        this._checkExperiment(experimentName);\n        this._enabledTransiently[experimentName] = true;\n    },\n\n    cleanUpStaleExperiments: function()\n    {\n        var experimentsSetting = Runtime._experimentsSetting();\n        var cleanedUpExperimentSetting = {};\n        for (var i = 0; i < this._experiments.length; ++i) {\n            var experimentName = this._experiments[i].name;\n            if (experimentsSetting[experimentName])\n                cleanedUpExperimentSetting[experimentName] = true;\n        }\n        this._setExperimentsSetting(cleanedUpExperimentSetting);\n    },\n\n    /**\n     * @param {string} experimentName\n     */\n    _checkExperiment: function(experimentName)\n    {\n        Runtime._assert(this._experimentNames[experimentName], \"Unknown experiment \" + experimentName);\n    }\n}\n\n/**\n * @constructor\n * @param {!Runtime.ExperimentsSupport} experiments\n * @param {string} name\n * @param {string} title\n * @param {boolean} hidden\n */\nRuntime.Experiment = function(experiments, name, title, hidden)\n{\n    this.name = name;\n    this.title = title;\n    this.hidden = hidden;\n    this._experiments = experiments;\n}\n\nRuntime.Experiment.prototype = {\n    /**\n     * @return {boolean}\n     */\n    isEnabled: function()\n    {\n        return this._experiments.isEnabled(this.name);\n    },\n\n    /**\n     * @param {boolean} enabled\n     */\n    setEnabled: function(enabled)\n    {\n        this._experiments.setEnabled(this.name, enabled);\n    }\n}\n\n{(function parseQueryParameters()\n{\n    var queryParams = location.search;\n    if (!queryParams)\n        return;\n    var params = queryParams.substring(1).split(\"&\");\n    for (var i = 0; i < params.length; ++i) {\n        var pair = params[i].split(\"=\");\n        Runtime._queryParamsObject[pair[0]] = pair[1];\n    }\n\n    // Patch settings from the URL param (for tests).\n    var settingsParam = Runtime.queryParam(\"settings\");\n    if (settingsParam) {\n        try {\n            var settings = JSON.parse(window.decodeURI(settingsParam));\n            for (var key in settings)\n                window.localStorage[key] = settings[key];\n        } catch(e) {\n            // Ignore malformed settings.\n        }\n    }\n})();}\n\n\n// This must be constructed after the query parameters have been parsed.\nRuntime.experiments = new Runtime.ExperimentsSupport();\n\n/** @type {!Runtime} */\nvar runtime;\n","/home/travis/build/npmtest/node-npmtest-node-inspector/node_modules/node-inspector/front-end/devtools.js":"// Copyright 2014 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nRuntime.startApplication(\"devtools\");\n","/home/travis/build/npmtest/node-npmtest-node-inspector/node_modules/node-inspector/front-end/externs.js":"/*\n * Copyright (C) 2011 Google Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n// WebKit Web Facing API\n\n/**\n * @param {!Object} object\n * @param {!Function} callback\n */\nObject.observe = function(object, callback) {}\n\n/** @type {boolean} */\nEvent.prototype.isMetaOrCtrlForTest;\n\n/**\n * @type {number}\n */\nKeyboardEvent.DOM_KEY_LOCATION_NUMPAD;\n\n/**\n * @param {!T} value\n * @param {boolean=} onlyFirst\n * @this {Array.<T>}\n * @template T\n */\nArray.prototype.remove = function(value, onlyFirst) {}\n/**\n * @param {!Array.<!T>} array\n * @this {Array.<!T>}\n * @template T\n */\nArray.prototype.pushAll = function(array) {}\n/**\n * @return {!Object.<string, boolean>}\n * @this {Array.<T>}\n * @template T\n */\nArray.prototype.keySet = function() {}\n/**\n * @param {number} index\n * @return {!Array.<!T>}\n * @this {Array.<T>}\n * @template T\n */\nArray.prototype.rotate = function(index) {}\n/**\n * @this {Array.<number>}\n */\nArray.prototype.sortNumbers = function() {}\n/**\n * @param {!T} object\n * @param {function(!T,!S):number=} comparator\n * @return {number}\n * @this {Array.<S>}\n * @template T,S\n */\nArray.prototype.lowerBound = function(object, comparator) {}\n/**\n * @param {!T} object\n * @param {function(!T,!S):number=} comparator\n * @return {number}\n * @this {Array.<S>}\n * @template T,S\n */\nArray.prototype.upperBound = function(object, comparator) {}\n/**\n * @param {!T} value\n * @param {function(!T,!S):number} comparator\n * @return {number}\n * @this {Array.<S>}\n * @template T,S\n */\nArray.prototype.binaryIndexOf = function(value, comparator) {}\n/**\n * @param {function(number, number): number} comparator\n * @param {number} leftBound\n * @param {number} rightBound\n * @param {number} sortWindowLeft\n * @param {number} sortWindowRight\n * @return {!Array.<number>}\n * @this {Array.<number>}\n */\nArray.prototype.sortRange = function(comparator, leftBound, rightBound, sortWindowLeft, sortWindowRight) {}\n\n/**\n * @param {function(!T,!T): number=} comparator\n * @return {!Array.<T>}\n * @this {Array.<T>}\n * @template T\n */\nArray.prototype.stableSort = function(comparator) {}\n\n/**\n * @this {Array.<number>}\n * @param {function(number,number):boolean} comparator\n * @param {number} left\n * @param {number} right\n * @param {number} pivotIndex\n * @return {number}\n */\nArray.prototype.partition = function(comparator, left, right, pivotIndex) {}\n\n/**\n * @this {Array.<number>}\n * @param {number} k\n * @param {function(number,number):boolean=} comparator\n * @return {number}\n */\nArray.prototype.qselect = function(k, comparator) {}\n\n/**\n * @param {string} field\n * @return {!Array.<!T>}\n * @this {Array.<!Object.<string,T>>}\n * @template T\n */\nArray.prototype.select = function(field) {}\n\n/**\n * @return {!T|undefined}\n * @this {Array.<T>}\n * @template T\n */\nArray.prototype.peekLast = function() {}\n\n/**\n * @param {!Array.<T>} array\n * @param {function(T,T):number} comparator\n * @return {!Array.<T>}\n * @this {!Array.<T>}\n * @template T\n */\nArray.prototype.intersectOrdered = function(array, comparator) {}\n\n/**\n * @param {!Array.<T>} array\n * @param {function(T,T):number} comparator\n * @return {!Array.<T>}\n * @this {!Array.<T>}\n * @template T\n */\nArray.prototype.mergeOrdered = function(array, comparator) {}\n\n// File System API\n/**\n * @constructor\n */\nfunction DOMFileSystem() {}\n\n/**\n * @type {DirectoryEntry}\n */\nDOMFileSystem.prototype.root = null;\n\nvar DevToolsHost = {};\n\n/** @typedef {{type:string, id:(number|undefined),\n              label:(string|undefined), enabled:(boolean|undefined), checked:(boolean|undefined),\n              subItems:(!Array.<!DevToolsHost.ContextMenuDescriptor>|undefined)}} */\nDevToolsHost.ContextMenuDescriptor;\n\n/**\n * @return {number}\n */\nDevToolsHost.zoomFactor = function() { }\n\n/**\n * @param {string} origin\n * @param {string} script\n */\nDevToolsHost.setInjectedScriptForOrigin = function(origin, script) { }\n\n/**\n * @param {string} text\n */\nDevToolsHost.copyText = function(text) { }\n\n/**\n * @return {string}\n */\nDevToolsHost.platform = function() { }\n\n/**\n * @param {number} x\n * @param {number} y\n * @param {!Array.<!DevToolsHost.ContextMenuDescriptor>} items\n * @param {!Document} document\n */\nDevToolsHost.showContextMenuAtPoint = function(x, y, items, document) { }\n\n/**\n * @param {string} message\n */\nDevToolsHost.sendMessageToBackend = function(message) { }\n\n/**\n * @param {string} message\n */\nDevToolsHost.sendMessageToEmbedder = function(message) { }\n\n/**\n * @return {string}\n */\nDevToolsHost.getSelectionBackgroundColor = function() { }\n\n/**\n * @return {string}\n */\nDevToolsHost.getSelectionForegroundColor = function() { }\n\n/**\n * @return {boolean}\n */\nDevToolsHost.isUnderTest = function() { }\n\n/**\n * @return {boolean}\n */\nDevToolsHost.isHostedMode = function() { }\n\n// FIXME: remove everything below.\nvar FormatterWorker = {}\nvar WebInspector = {}\n\nWebInspector.panels = {};\n\nWebInspector.reload = function() { }\n\n/** Extensions API */\n\n/** @constructor */\nfunction AuditCategory() {}\n/** @constructor */\nfunction AuditResult() {}\n/** @constructor */\nfunction EventSink() {}\n/** @constructor */\nfunction ExtensionSidebarPane() {}\n/** @constructor */\nfunction Panel() {}\n/** @constructor */\nfunction PanelWithSidebar() {}\n/** @constructor */\nfunction Request() {}\n/** @constructor */\nfunction Resource() {}\n/** @constructor */\nfunction Timeline() {}\n\nvar extensionServer;\n\n/**\n * @constructor\n */\nfunction ExtensionDescriptor() {\n    this.startPage = \"\";\n    this.name = \"\";\n}\n\n/**\n * @constructor\n */\nfunction ExtensionReloadOptions() {\n    this.ignoreCache = false;\n    this.injectedScript = \"\";\n    this.preprocessingScript = \"\";\n    this.userAgent = \"\";\n}\n\nvar Adb = {};\n/** @typedef {{id: string, adbBrowserChromeVersion: string, compatibleVersion: boolean, adbBrowserName: string, source: string, adbBrowserVersion: string}} */\nAdb.Browser;\n/** @typedef {{id: string, adbModel: string, adbSerial: string, browsers: !Array.<!Adb.Browser>, adbPortStatus: !Array.<number>, adbConnected: boolean}} */\nAdb.Device;\n\n/* jsdifflib API */\nvar difflib = {};\ndifflib.stringAsLines = function(text) { return []; }\n/** @constructor */\ndifflib.SequenceMatcher = function(baseText, newText) { }\ndifflib.SequenceMatcher.prototype.get_opcodes = function() { return []; }\n\n/** @constructor */\nvar Doc = function() { }\nDoc.prototype = {\n    /** @type {number} */\n    scrollLeft: 0,\n    /** @type {number} */\n    scrollTop: 0\n}\n\n/** @constructor */\nvar CodeMirror = function(element, config) { }\nCodeMirror.on = function(obj, type, handler) { }\nCodeMirror.prototype = {\n    /** @type {!Doc} */\n    doc: null,\n    addKeyMap: function(map) { },\n    addLineClass: function(handle, where, cls) { },\n    /** @param {?Object=} options */\n    addLineWidget: function(handle, node, options) { },\n    /**\n     * @param {string|!Object} spec\n     * @param {!Object=} options\n     */\n    addOverlay: function(spec, options) { },\n    addWidget: function(pos, node, scroll, vert, horiz) { },\n    charCoords: function(pos, mode) { },\n    clearGutter: function(gutterID) { },\n    clearHistory: function() { },\n    clipPos: function(pos) { },\n    /** @param {string=} mode */\n    coordsChar: function(coords, mode) { },\n    /** @param {string=} mode */\n    cursorCoords: function(start, mode) { },\n    defaultCharWidth: function() { },\n    defaultTextHeight: function() { },\n    deleteH: function(dir, unit) { },\n    /**\n     * @param {*=} to\n     * @param {*=} op\n     */\n    eachLine: function(from, to, op) { },\n    execCommand: function(cmd) { },\n    extendSelection: function(from, to) { },\n    findMarksAt: function(pos) { },\n    /**\n     * @param {!CodeMirror.Pos} from\n     * @param {boolean=} strict\n     * @param {Object=} config\n     */\n    findMatchingBracket: function(from, strict, config) { },\n    findPosH: function(from, amount, unit, visually) { },\n    findPosV: function(from, amount, unit, goalColumn) { },\n    firstLine: function() { },\n    focus: function() { },\n    getAllMarks: function() { },\n    /** @param {string=} start */\n    getCursor: function(start) { },\n    getDoc: function() { },\n    getGutterElement: function() { },\n    getHistory: function() { },\n    getInputField: function(){ },\n    getLine: function(line) { },\n    /**\n     * @return {!{wrapClass: string}}\n     */\n    getLineHandle: function(line) { },\n    getLineNumber: function(line) { },\n    getMode: function() { },\n    getOption: function(option) { },\n    /** @param {*=} lineSep */\n    getRange: function(from, to, lineSep) { },\n    /**\n     * @return {!{left: number, top: number, width: number, height: number, clientWidth: number, clientHeight: number}}\n     */\n    getScrollInfo: function() { },\n    getScrollerElement: function() { },\n    getSelection: function() { },\n    getSelections: function() { },\n    getStateAfter: function(line) { },\n    getTokenAt: function(pos) { },\n    /** @param {*=} lineSep */\n    getValue: function(lineSep) { },\n    getViewport: function() { },\n    getWrapperElement: function() { },\n    hasFocus: function() { },\n    historySize: function() { },\n    indentLine: function(n, dir, aggressive) { },\n    indentSelection: function(how) { },\n    indexFromPos: function(coords) { },\n    isClean: function() { },\n    iterLinkedDocs: function(f) { },\n    lastLine: function() { },\n    lineCount: function() { },\n    lineInfo: function(line) { },\n    /**\n     * @param {number} height\n     * @param {string=} mode\n     */\n    lineAtHeight: function(height, mode) { },\n    linkedDoc: function(options) { },\n    listSelections: function() { },\n    markClean: function() { },\n    markText: function(from, to, options) { },\n    moveH: function(dir, unit) { },\n    moveV: function(dir, unit) { },\n    off: function(type, f) { },\n    on: function(type, f) { },\n    operation: function(f) { },\n    posFromIndex: function(off) { },\n    redo: function() { },\n    refresh: function() { },\n    removeKeyMap: function(map) { },\n    removeLine: function(line) { },\n    removeLineClass: function(handle, where, cls) { },\n    removeLineWidget: function(widget) { },\n    removeOverlay: function(spec) { },\n    /** @param {*=} origin */\n    replaceRange: function(code, from, to, origin) { },\n    /**\n     * @param {string} replacement\n     * @param {string=} select\n     */\n    replaceSelection: function(replacement, select) { },\n    /**\n     * @param {!Array.<string>} textPerSelection\n     */\n    replaceSelections: function(textPerSelection) { },\n    /** @param {*=} margin */\n    scrollIntoView: function(pos, margin) { },\n    scrollTo: function(x, y) { },\n    setBookmark: function(pos, options) { },\n    setCursor: function(line, ch, extend) { },\n    setExtending: function(val) { },\n    setGutterMarker: function(line, gutterID, value) { },\n    setHistory: function(histData) { },\n    setLine: function(line, text) { },\n    setOption: function(option, value) { },\n    setSelection: function(anchor, head) { },\n    /**\n     * @param {number=} primaryIndex\n     * @param {?Object=} config\n     */\n    setSelections: function(selections, primaryIndex, config) { },\n    setSize: function(width, height) { },\n    setValue: function(code) { },\n    somethingSelected: function() { },\n    swapDoc: function(doc) { },\n    undo: function() { },\n    unlinkDoc: function(other) { }\n}\n/** @type {!{cursorDiv: Element}} */\nCodeMirror.prototype.display;\n/** @type {!Object} */\nCodeMirror.Pass;\nCodeMirror.showHint = function(codeMirror, hintintFunction) { };\nCodeMirror.commands = {};\nCodeMirror.modes = {};\nCodeMirror.mimeModes = {};\nCodeMirror.getMode = function(options, spec) { };\nCodeMirror.overlayMode = function(mode1, mode2, squashSpans) { };\nCodeMirror.defineMode = function(modeName, modeConstructor) { };\nCodeMirror.startState = function(mode) { };\n\n/** @constructor */\nCodeMirror.Pos = function(line, ch) { }\n/** @type {number} */\nCodeMirror.Pos.prototype.line;\n/** @type {number} */\nCodeMirror.Pos.prototype.ch;\n\n/**\n * @param {!CodeMirror.Pos} pos1\n * @param {!CodeMirror.Pos} pos2\n * @return {number}\n */\nCodeMirror.cmpPos = function(pos1, pos2) { };\n\n/** @constructor */\nCodeMirror.StringStream = function(line)\n{\n    this.pos = 0;\n    this.start = 0;\n}\nCodeMirror.StringStream.prototype = {\n    backUp: function (n) { },\n    column: function () { },\n    current: function () { },\n    eat: function (match) { },\n    eatSpace: function () { },\n    eatWhile: function (match) { },\n    eol: function () { },\n    indentation: function () { },\n    /**\n     * @param {!RegExp|string} pattern\n     * @param {boolean=} consume\n     * @param {boolean=} caseInsensitive\n     */\n    match: function (pattern, consume, caseInsensitive) { },\n    next: function () { },\n    peek: function () { },\n    skipTo: function (ch) { },\n    skipToEnd: function () { },\n    sol: function () { }\n}\n\n/** @type {Object.<string, !Object.<string, string>>} */\nCodeMirror.keyMap;\n\n/** @type {{scrollLeft: number, scrollTop: number}} */\nCodeMirror.doc;\n\n/** @type {boolean} */\nwindow.dispatchStandaloneTestRunnerMessages;\n\n// FIXME: Remove once ES6 is supported natively by JS compiler.\n\n/** @typedef {string} */\nvar symbol;\n\n/**\n * @param {string} description\n * @return {symbol}\n */\nfunction Symbol(description) {}\n\n/**\n * @interface\n * @extends $jscomp.Iterable.<T>\n * @template T\n */\nvar Iterator = function() { }\n\nIterator.prototype = {\n    /**\n     * @return {{done: boolean, value: (T|undefined)}}\n     */\n    next: function() { },\n\n    // FIXME: This should be removed once transpilation is not required for closure compiler ES6\n    $$iterator: function() { }\n}\n\n// FIXME: $jscomp.Iterable hack below should be removed once transpilation is not required for closure compiler ES6\n/**\n * @constructor\n * @implements $jscomp.Iterable.<!Array.<K|V>>\n * @param {!Array.<!Array.<K|V>>|!Iterator.<!Array.<K|V>>=} iterable\n * @template K, V\n */\nvar Map = function(iterable) { }\n\nMap.prototype = {\n    /**\n     * @param {K} key\n     * @param {V} value\n     */\n    set: function(key, value) { },\n\n    /**\n     * @param {K} key\n     * @return {boolean}\n     */\n    delete: function(key) { },\n\n    /**\n     * @return {!Iterator.<K>}\n     */\n    keys: function() { },\n\n    /**\n     * @return {!Iterator.<V>}\n     */\n    values: function() { },\n\n    /**\n     * @return {!Array.<!Array.<K|V>>}\n     */\n    entries: function() { },\n\n    /**\n     * @param {K} key\n     * @return {V}\n     */\n    get: function(key) { },\n\n    /**\n     * @param {K} key\n     * @return {boolean}\n     */\n    has: function(key) { },\n\n    clear: function() { },\n\n    /**\n     * @return {number}\n     */\n    get size() { },\n\n    // FIXME: This should be removed once transpilation is not required for closure compiler ES6\n    $$iterator: function() { }\n}\n\n// FIXME: $jscomp.Iterable hack below should be removed once transpilation is not required for closure compiler ES6\n/**\n * @constructor\n * @implements $jscomp.Iterable.<V>\n * @param {!Array.<V>|!Iterator.<V>=} iterable\n * @template V\n */\nvar Set = function(iterable) { }\n\nSet.prototype = {\n    /**\n     * @param {V} value\n     */\n    add: function(value) { },\n\n    /**\n     * @param {V} value\n     * @return {boolean}\n     */\n    delete: function(value) { },\n\n    /**\n     * @return {!Iterator.<V>}\n     */\n    values: function() { },\n\n    /**\n     * @param {V} value\n     * @return {boolean}\n     */\n    has: function(value) { },\n\n    clear: function() { },\n\n    /**\n     * @return {number}\n     */\n    get size() { },\n\n    // FIXME: This should be removed once transpilation is not required for closure compiler ES6\n    $$iterator: function() { }\n}\n","/home/travis/build/npmtest/node-npmtest-node-inspector/node_modules/node-inspector/front-end/inspector.js":"// Copyright 2014 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nRuntime.startApplication(\"inspector\");\n","/home/travis/build/npmtest/node-npmtest-node-inspector/node_modules/node-inspector/front-end/toolbox.js":"// Copyright 2014 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nRuntime.startApplication(\"toolbox\");\n","/home/travis/build/npmtest/node-npmtest-node-inspector/node_modules/node-inspector/front-end/treeoutline.js":"/*\n * Copyright (C) 2007 Apple Inc.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1.  Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n * 2.  Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n * 3.  Neither the name of Apple Computer, Inc. (\"Apple\") nor the names of\n *     its contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * @constructor\n * @param {Element} listNode\n * @param {boolean=} nonFocusable\n */\nfunction TreeOutline(listNode, nonFocusable)\n{\n    /** @type {!Array.<TreeElement>} */\n    this.children = [];\n    this.selectedTreeElement = null;\n    this._childrenListNode = listNode;\n    this.childrenListElement = this._childrenListNode;\n    this._childrenListNode.removeChildren();\n    this.expandTreeElementsWhenArrowing = false;\n    this.root = true;\n    this.hasChildren = false;\n    this.expanded = true;\n    this.selected = false;\n    this.treeOutline = this;\n    /** @type {function(TreeElement,TreeElement):number|null} */\n    this.comparator = null;\n\n    this.setFocusable(!nonFocusable);\n    this._childrenListNode.addEventListener(\"keydown\", this._treeKeyDown.bind(this), true);\n\n    /** @type {!Map.<!Object, !Array.<!TreeElement>>} */\n    this._treeElementsMap = new Map();\n    /** @type {!Map.<!Object, boolean>} */\n    this._expandedStateMap = new Map();\n}\n\nTreeOutline.prototype.setFocusable = function(focusable)\n{\n    if (focusable)\n        this._childrenListNode.setAttribute(\"tabIndex\", 0);\n    else\n        this._childrenListNode.removeAttribute(\"tabIndex\");\n}\n\n/**\n * @param {TreeElement} child\n */\nTreeOutline.prototype.appendChild = function(child)\n{\n    var insertionIndex;\n    if (this.treeOutline.comparator)\n        insertionIndex = insertionIndexForObjectInListSortedByFunction(child, this.children, this.treeOutline.comparator);\n    else\n        insertionIndex = this.children.length;\n    this.insertChild(child, insertionIndex);\n}\n\n/**\n * @param {TreeElement} child\n * @param {TreeElement} beforeChild\n */\nTreeOutline.prototype.insertBeforeChild = function(child, beforeChild)\n{\n    if (!child)\n        throw(\"child can't be undefined or null\");\n\n    if (!beforeChild)\n        throw(\"beforeChild can't be undefined or null\");\n\n    var childIndex = this.children.indexOf(beforeChild);\n    if (childIndex === -1)\n        throw(\"beforeChild not found in this node's children\");\n\n    this.insertChild(child, childIndex);\n}\n\n/**\n * @param {TreeElement} child\n * @param {number} index\n */\nTreeOutline.prototype.insertChild = function(child, index)\n{\n    if (!child)\n        throw(\"child can't be undefined or null\");\n\n    var previousChild = (index > 0 ? this.children[index - 1] : null);\n    if (previousChild) {\n        previousChild.nextSibling = child;\n        child.previousSibling = previousChild;\n    } else {\n        child.previousSibling = null;\n    }\n\n    var nextChild = this.children[index];\n    if (nextChild) {\n        nextChild.previousSibling = child;\n        child.nextSibling = nextChild;\n    } else {\n        child.nextSibling = null;\n    }\n\n    this.children.splice(index, 0, child);\n    this.hasChildren = true;\n    child.parent = this;\n    child.treeOutline = this.treeOutline;\n    child.treeOutline._rememberTreeElement(child);\n\n    var current = child.children[0];\n    while (current) {\n        current.treeOutline = this.treeOutline;\n        current.treeOutline._rememberTreeElement(current);\n        current = current.traverseNextTreeElement(false, child, true);\n    }\n\n    if (child.hasChildren && typeof(child.treeOutline._expandedStateMap.get(child.representedObject)) !== \"undefined\")\n        child.expanded = child.treeOutline._expandedStateMap.get(child.representedObject);\n\n    if (!this._childrenListNode) {\n        this._childrenListNode = this.treeOutline._childrenListNode.ownerDocument.createElement(\"ol\");\n        this._childrenListNode.parentTreeElement = this;\n        this._childrenListNode.classList.add(\"children\");\n        if (this.hidden)\n            this._childrenListNode.classList.add(\"hidden\");\n    }\n\n    child._attach();\n}\n\n/**\n * @param {number} childIndex\n */\nTreeOutline.prototype.removeChildAtIndex = function(childIndex)\n{\n    if (childIndex < 0 || childIndex >= this.children.length)\n        throw(\"childIndex out of range\");\n\n    var child = this.children[childIndex];\n    this.children.splice(childIndex, 1);\n\n    var parent = child.parent;\n    if (child.deselect()) {\n        if (child.previousSibling)\n            child.previousSibling.select();\n        else if (child.nextSibling)\n            child.nextSibling.select();\n        else\n            parent.select();\n    }\n\n    if (child.previousSibling)\n        child.previousSibling.nextSibling = child.nextSibling;\n    if (child.nextSibling)\n        child.nextSibling.previousSibling = child.previousSibling;\n\n    if (child.treeOutline) {\n        child.treeOutline._forgetTreeElement(child);\n        child.treeOutline._forgetChildrenRecursive(child);\n    }\n\n    child._detach();\n    child.treeOutline = null;\n    child.parent = null;\n    child.nextSibling = null;\n    child.previousSibling = null;\n}\n\n/**\n * @param {TreeElement} child\n */\nTreeOutline.prototype.removeChild = function(child)\n{\n    if (!child)\n        throw(\"child can't be undefined or null\");\n\n    var childIndex = this.children.indexOf(child);\n    if (childIndex === -1)\n        throw(\"child not found in this node's children\");\n\n    this.removeChildAtIndex.call(this, childIndex);\n}\n\nTreeOutline.prototype.removeChildren = function()\n{\n    for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i];\n        child.deselect();\n\n        if (child.treeOutline) {\n            child.treeOutline._forgetTreeElement(child);\n            child.treeOutline._forgetChildrenRecursive(child);\n        }\n\n        child._detach();\n        child.treeOutline = null;\n        child.parent = null;\n        child.nextSibling = null;\n        child.previousSibling = null;\n    }\n\n    this.children = [];\n}\n\n/**\n * @param {TreeElement} element\n */\nTreeOutline.prototype._rememberTreeElement = function(element)\n{\n    if (!this._treeElementsMap.get(element.representedObject))\n        this._treeElementsMap.put(element.representedObject, []);\n        \n    // check if the element is already known\n    var elements = this._treeElementsMap.get(element.representedObject);\n    if (elements.indexOf(element) !== -1)\n        return;\n\n    // add the element\n    elements.push(element);\n}\n\n/**\n * @param {TreeElement} element\n */\nTreeOutline.prototype._forgetTreeElement = function(element)\n{\n    if (this._treeElementsMap.get(element.representedObject)) {\n        var elements = this._treeElementsMap.get(element.representedObject);\n        elements.remove(element, true);\n        if (!elements.length)\n            this._treeElementsMap.remove(element.representedObject);\n    }\n}\n\n/**\n * @param {TreeElement} parentElement\n */\nTreeOutline.prototype._forgetChildrenRecursive = function(parentElement)\n{\n    var child = parentElement.children[0];\n    while (child) {\n        this._forgetTreeElement(child);\n        child = child.traverseNextTreeElement(false, parentElement, true);\n    }\n}\n\n/**\n * @param {Object} representedObject\n * @return {TreeElement}\n */\nTreeOutline.prototype.getCachedTreeElement = function(representedObject)\n{\n    if (!representedObject)\n        return null;\n\n    var elements = this._treeElementsMap.get(representedObject);\n    if (elements && elements.length)\n        return elements[0];\n    return null;\n}\n\n/**\n * @param {Object} representedObject\n * @return {TreeElement}\n */\nTreeOutline.prototype.findTreeElement = function(representedObject, isAncestor, getParent)\n{\n    if (!representedObject)\n        return null;\n\n    var cachedElement = this.getCachedTreeElement(representedObject);\n    if (cachedElement)\n        return cachedElement;\n\n    // Walk up the parent pointers from the desired representedObject \n    var ancestors = [];\n    for (var currentObject = getParent(representedObject); currentObject;  currentObject = getParent(currentObject)) {\n        ancestors.push(currentObject);\n        if (this.getCachedTreeElement(currentObject))  // stop climbing as soon as we hit\n            break;\n    }\n        \n    if (!currentObject)\n        return null;\n\n    // Walk down to populate each ancestor's children, to fill in the tree and the cache.\n    for (var i = ancestors.length - 1; i >= 0; --i) {\n        var treeElement = this.getCachedTreeElement(ancestors[i]);\n        if (treeElement)\n            treeElement.onpopulate();  // fill the cache with the children of treeElement\n    }\n\n    return this.getCachedTreeElement(representedObject);\n}\n\n/**\n * @param {number} x\n * @param {number} y\n * @return {TreeElement}\n */\nTreeOutline.prototype.treeElementFromPoint = function(x, y)\n{\n    var node = this._childrenListNode.ownerDocument.elementFromPoint(x, y);\n    if (!node)\n        return null;\n\n    var listNode = node.enclosingNodeOrSelfWithNodeNameInArray([\"ol\", \"li\"]);\n    if (listNode)\n        return listNode.parentTreeElement || listNode.treeElement;\n    return null;\n}\n\nTreeOutline.prototype._treeKeyDown = function(event)\n{\n    if (event.target !== this._childrenListNode)\n        return;\n\n    if (!this.selectedTreeElement || event.shiftKey || event.metaKey || event.ctrlKey)\n        return;\n\n    var handled = false;\n    var nextSelectedElement;\n    if (event.keyIdentifier === \"Up\" && !event.altKey) {\n        nextSelectedElement = this.selectedTreeElement.traversePreviousTreeElement(true);\n        while (nextSelectedElement && !nextSelectedElement.selectable)\n            nextSelectedElement = nextSelectedElement.traversePreviousTreeElement(!this.expandTreeElementsWhenArrowing);\n        handled = nextSelectedElement ? true : false;\n    } else if (event.keyIdentifier === \"Down\" && !event.altKey) {\n        nextSelectedElement = this.selectedTreeElement.traverseNextTreeElement(true);\n        while (nextSelectedElement && !nextSelectedElement.selectable)\n            nextSelectedElement = nextSelectedElement.traverseNextTreeElement(!this.expandTreeElementsWhenArrowing);\n        handled = nextSelectedElement ? true : false;\n    } else if (event.keyIdentifier === \"Left\") {\n        if (this.selectedTreeElement.expanded) {\n            if (event.altKey)\n                this.selectedTreeElement.collapseRecursively();\n            else\n                this.selectedTreeElement.collapse();\n            handled = true;\n        } else if (this.selectedTreeElement.parent && !this.selectedTreeElement.parent.root) {\n            handled = true;\n            if (this.selectedTreeElement.parent.selectable) {\n                nextSelectedElement = this.selectedTreeElement.parent;\n                while (nextSelectedElement && !nextSelectedElement.selectable)\n                    nextSelectedElement = nextSelectedElement.parent;\n                handled = nextSelectedElement ? true : false;\n            } else if (this.selectedTreeElement.parent)\n                this.selectedTreeElement.parent.collapse();\n        }\n    } else if (event.keyIdentifier === \"Right\") {\n        if (!this.selectedTreeElement.revealed()) {\n            this.selectedTreeElement.reveal();\n            handled = true;\n        } else if (this.selectedTreeElement.hasChildren) {\n            handled = true;\n            if (this.selectedTreeElement.expanded) {\n                nextSelectedElement = this.selectedTreeElement.children[0];\n                while (nextSelectedElement && !nextSelectedElement.selectable)\n                    nextSelectedElement = nextSelectedElement.nextSibling;\n                handled = nextSelectedElement ? true : false;\n            } else {\n                if (event.altKey)\n                    this.selectedTreeElement.expandRecursively();\n                else\n                    this.selectedTreeElement.expand();\n            }\n        }\n    } else if (event.keyCode === 8 /* Backspace */ || event.keyCode === 46 /* Delete */)\n        handled = this.selectedTreeElement.ondelete();\n    else if (isEnterKey(event))\n        handled = this.selectedTreeElement.onenter();\n    else if (event.keyCode === WebInspector.KeyboardShortcut.Keys.Space.code)\n        handled = this.selectedTreeElement.onspace();\n\n    if (nextSelectedElement) {\n        nextSelectedElement.reveal();\n        nextSelectedElement.select(false, true);\n    }\n\n    if (handled)\n        event.consume(true);\n}\n\nTreeOutline.prototype.expand = function()\n{\n    // this is the root, do nothing\n}\n\nTreeOutline.prototype.collapse = function()\n{\n    // this is the root, do nothing\n}\n\nTreeOutline.prototype.revealed = function()\n{\n    return true;\n}\n\nTreeOutline.prototype.reveal = function()\n{\n    // this is the root, do nothing\n}\n\nTreeOutline.prototype.select = function()\n{\n    // this is the root, do nothing\n}\n\n/**\n * @param {boolean=} omitFocus\n */\nTreeOutline.prototype.revealAndSelect = function(omitFocus)\n{\n    // this is the root, do nothing\n}\n\n/**\n * @constructor\n * @param {Object=} representedObject\n * @param {boolean=} hasChildren\n */\nfunction TreeElement(title, representedObject, hasChildren)\n{\n    this._title = title;\n    this.representedObject = (representedObject || {});\n\n    this._hidden = false;\n    this._selectable = true;\n    this.expanded = false;\n    this.selected = false;\n    this.hasChildren = hasChildren;\n    this.children = [];\n    this.treeOutline = null;\n    this.parent = null;\n    this.previousSibling = null;\n    this.nextSibling = null;\n    this._listItemNode = null;\n}\n\nTreeElement.prototype = {\n    arrowToggleWidth: 10,\n\n    get selectable() {\n        if (this._hidden)\n            return false;\n        return this._selectable;\n    },\n\n    set selectable(x) {\n        this._selectable = x;\n    },\n\n    get listItemElement() {\n        return this._listItemNode;\n    },\n\n    get childrenListElement() {\n        return this._childrenListNode;\n    },\n\n    get title() {\n        return this._title;\n    },\n\n    set title(x) {\n        this._title = x;\n        this._setListItemNodeContent();\n    },\n\n    get tooltip() {\n        return this._tooltip;\n    },\n\n    set tooltip(x) {\n        this._tooltip = x;\n        if (this._listItemNode)\n            this._listItemNode.title = x ? x : \"\";\n    },\n\n    get hasChildren() {\n        return this._hasChildren;\n    },\n\n    set hasChildren(x) {\n        if (this._hasChildren === x)\n            return;\n\n        this._hasChildren = x;\n\n        if (!this._listItemNode)\n            return;\n\n        if (x)\n            this._listItemNode.classList.add(\"parent\");\n        else {\n            this._listItemNode.classList.remove(\"parent\");\n            this.collapse();\n        }\n    },\n\n    get hidden() {\n        return this._hidden;\n    },\n\n    set hidden(x) {\n        if (this._hidden === x)\n            return;\n\n        this._hidden = x;\n\n        if (x) {\n            if (this._listItemNode)\n                this._listItemNode.classList.add(\"hidden\");\n            if (this._childrenListNode)\n                this._childrenListNode.classList.add(\"hidden\");\n        } else {\n            if (this._listItemNode)\n                this._listItemNode.classList.remove(\"hidden\");\n            if (this._childrenListNode)\n                this._childrenListNode.classList.remove(\"hidden\");\n        }\n    },\n\n    get shouldRefreshChildren() {\n        return this._shouldRefreshChildren;\n    },\n\n    set shouldRefreshChildren(x) {\n        this._shouldRefreshChildren = x;\n        if (x && this.expanded)\n            this.expand();\n    },\n\n    _setListItemNodeContent: function()\n    {\n        if (!this._listItemNode)\n            return;\n\n        if (typeof this._title === \"string\")\n            this._listItemNode.textContent = this._title;\n        else {\n            this._listItemNode.removeChildren();\n            if (this._title)\n                this._listItemNode.appendChild(this._title);\n        }\n    }\n}\n\nTreeElement.prototype.appendChild = TreeOutline.prototype.appendChild;\nTreeElement.prototype.insertChild = TreeOutline.prototype.insertChild;\nTreeElement.prototype.insertBeforeChild = TreeOutline.prototype.insertBeforeChild;\nTreeElement.prototype.removeChild = TreeOutline.prototype.removeChild;\nTreeElement.prototype.removeChildAtIndex = TreeOutline.prototype.removeChildAtIndex;\nTreeElement.prototype.removeChildren = TreeOutline.prototype.removeChildren;\n\nTreeElement.prototype._attach = function()\n{\n    if (!this._listItemNode || this.parent._shouldRefreshChildren) {\n        if (this._listItemNode && this._listItemNode.parentNode)\n            this._listItemNode.parentNode.removeChild(this._listItemNode);\n\n        this._listItemNode = this.treeOutline._childrenListNode.ownerDocument.createElement(\"li\");\n        this._listItemNode.treeElement = this;\n        this._setListItemNodeContent();\n        this._listItemNode.title = this._tooltip ? this._tooltip : \"\";\n\n        if (this.hidden)\n            this._listItemNode.classList.add(\"hidden\");\n        if (this.hasChildren)\n            this._listItemNode.classList.add(\"parent\");\n        if (this.expanded)\n            this._listItemNode.classList.add(\"expanded\");\n        if (this.selected)\n            this._listItemNode.classList.add(\"selected\");\n\n        this._listItemNode.addEventListener(\"mousedown\", TreeElement.treeElementMouseDown, false);\n        this._listItemNode.addEventListener(\"click\", TreeElement.treeElementToggled, false);\n        this._listItemNode.addEventListener(\"dblclick\", TreeElement.treeElementDoubleClicked, false);\n\n        this.onattach();\n    }\n\n    var nextSibling = null;\n    if (this.nextSibling && this.nextSibling._listItemNode && this.nextSibling._listItemNode.parentNode === this.parent._childrenListNode)\n        nextSibling = this.nextSibling._listItemNode;\n    this.parent._childrenListNode.insertBefore(this._listItemNode, nextSibling);\n    if (this._childrenListNode)\n        this.parent._childrenListNode.insertBefore(this._childrenListNode, this._listItemNode.nextSibling);\n    if (this.selected)\n        this.select();\n    if (this.expanded)\n        this.expand();\n}\n\nTreeElement.prototype._detach = function()\n{\n    if (this._listItemNode && this._listItemNode.parentNode)\n        this._listItemNode.parentNode.removeChild(this._listItemNode);\n    if (this._childrenListNode && this._childrenListNode.parentNode)\n        this._childrenListNode.parentNode.removeChild(this._childrenListNode);\n}\n\nTreeElement.treeElementMouseDown = function(event)\n{\n    var element = event.currentTarget;\n    if (!element || !element.treeElement || !element.treeElement.selectable)\n        return;\n\n    if (element.treeElement.isEventWithinDisclosureTriangle(event))\n        return;\n\n    element.treeElement.selectOnMouseDown(event);\n}\n\nTreeElement.treeElementToggled = function(event)\n{\n    var element = event.currentTarget;\n    if (!element || !element.treeElement)\n        return;\n\n    var toggleOnClick = element.treeElement.toggleOnClick && !element.treeElement.selectable;\n    var isInTriangle = element.treeElement.isEventWithinDisclosureTriangle(event);\n    if (!toggleOnClick && !isInTriangle)\n        return;\n\n    if (element.treeElement.expanded) {\n        if (event.altKey)\n            element.treeElement.collapseRecursively();\n        else\n            element.treeElement.collapse();\n    } else {\n        if (event.altKey)\n            element.treeElement.expandRecursively();\n        else\n            element.treeElement.expand();\n    }\n    event.consume();\n}\n\nTreeElement.treeElementDoubleClicked = function(event)\n{\n    var element = event.currentTarget;\n    if (!element || !element.treeElement)\n        return;\n\n    var handled = element.treeElement.ondblclick.call(element.treeElement, event);\n    if (handled)\n        return;\n    if (element.treeElement.hasChildren && !element.treeElement.expanded)\n        element.treeElement.expand();\n}\n\nTreeElement.prototype.collapse = function()\n{\n    if (this._listItemNode)\n        this._listItemNode.classList.remove(\"expanded\");\n    if (this._childrenListNode)\n        this._childrenListNode.classList.remove(\"expanded\");\n\n    this.expanded = false;\n    \n    if (this.treeOutline)\n        this.treeOutline._expandedStateMap.put(this.representedObject, false);\n\n    this.oncollapse();\n}\n\nTreeElement.prototype.collapseRecursively = function()\n{\n    var item = this;\n    while (item) {\n        if (item.expanded)\n            item.collapse();\n        item = item.traverseNextTreeElement(false, this, true);\n    }\n}\n\nTreeElement.prototype.expand = function()\n{\n    if (!this.hasChildren || (this.expanded && !this._shouldRefreshChildren && this._childrenListNode))\n        return;\n\n    // Set this before onpopulate. Since onpopulate can add elements, this makes\n    // sure the expanded flag is true before calling those functions. This prevents the possibility\n    // of an infinite loop if onpopulate were to call expand.\n\n    this.expanded = true;\n    if (this.treeOutline)\n        this.treeOutline._expandedStateMap.put(this.representedObject, true);\n\n    if (this.treeOutline && (!this._childrenListNode || this._shouldRefreshChildren)) {\n        if (this._childrenListNode && this._childrenListNode.parentNode)\n            this._childrenListNode.parentNode.removeChild(this._childrenListNode);\n\n        this._childrenListNode = this.treeOutline._childrenListNode.ownerDocument.createElement(\"ol\");\n        this._childrenListNode.parentTreeElement = this;\n        this._childrenListNode.classList.add(\"children\");\n\n        if (this.hidden)\n            this._childrenListNode.classList.add(\"hidden\");\n\n        this.onpopulate();\n\n        for (var i = 0; i < this.children.length; ++i)\n            this.children[i]._attach();\n\n        delete this._shouldRefreshChildren;\n    }\n\n    if (this._listItemNode) {\n        this._listItemNode.classList.add(\"expanded\");\n        if (this._childrenListNode && this._childrenListNode.parentNode != this._listItemNode.parentNode)\n            this.parent._childrenListNode.insertBefore(this._childrenListNode, this._listItemNode.nextSibling);\n    }\n\n    if (this._childrenListNode)\n        this._childrenListNode.classList.add(\"expanded\");\n\n    this.onexpand();\n}\n\nTreeElement.prototype.expandRecursively = function(maxDepth)\n{\n    var item = this;\n    var info = {};\n    var depth = 0;\n\n    // The Inspector uses TreeOutlines to represents object properties, so recursive expansion\n    // in some case can be infinite, since JavaScript objects can hold circular references.\n    // So default to a recursion cap of 3 levels, since that gives fairly good results.\n    if (isNaN(maxDepth))\n        maxDepth = 3;\n\n    while (item) {\n        if (depth < maxDepth)\n            item.expand();\n        item = item.traverseNextTreeElement(false, this, (depth >= maxDepth), info);\n        depth += info.depthChange;\n    }\n}\n\nTreeElement.prototype.hasAncestor = function(ancestor) {\n    if (!ancestor)\n        return false;\n\n    var currentNode = this.parent;\n    while (currentNode) {\n        if (ancestor === currentNode)\n            return true;\n        currentNode = currentNode.parent;\n    }\n\n    return false;\n}\n\nTreeElement.prototype.reveal = function()\n{\n    var currentAncestor = this.parent;\n    while (currentAncestor && !currentAncestor.root) {\n        if (!currentAncestor.expanded)\n            currentAncestor.expand();\n        currentAncestor = currentAncestor.parent;\n    }\n\n    this.onreveal(this);\n}\n\nTreeElement.prototype.revealed = function()\n{\n    var currentAncestor = this.parent;\n    while (currentAncestor && !currentAncestor.root) {\n        if (!currentAncestor.expanded)\n            return false;\n        currentAncestor = currentAncestor.parent;\n    }\n\n    return true;\n}\n\nTreeElement.prototype.selectOnMouseDown = function(event)\n{\n    if (this.select(false, true))\n        event.consume(true);\n}\n\n/**\n * @param {boolean=} omitFocus\n * @param {boolean=} selectedByUser\n * @return {boolean}\n */\nTreeElement.prototype.select = function(omitFocus, selectedByUser)\n{\n    if (!this.treeOutline || !this.selectable || this.selected)\n        return false;\n\n    if (this.treeOutline.selectedTreeElement)\n        this.treeOutline.selectedTreeElement.deselect();\n\n    this.selected = true;\n\n    if(!omitFocus)\n        this.treeOutline._childrenListNode.focus();\n\n    // Focusing on another node may detach \"this\" from tree.\n    if (!this.treeOutline)\n        return false;\n    this.treeOutline.selectedTreeElement = this;\n    if (this._listItemNode)\n        this._listItemNode.classList.add(\"selected\");\n\n    return this.onselect(selectedByUser);\n}\n\n/**\n * @param {boolean=} omitFocus\n */\nTreeElement.prototype.revealAndSelect = function(omitFocus)\n{\n    this.reveal();\n    this.select(omitFocus);\n}\n\n/**\n * @param {boolean=} supressOnDeselect\n */\nTreeElement.prototype.deselect = function(supressOnDeselect)\n{\n    if (!this.treeOutline || this.treeOutline.selectedTreeElement !== this || !this.selected)\n        return false;\n\n    this.selected = false;\n    this.treeOutline.selectedTreeElement = null;\n    if (this._listItemNode)\n        this._listItemNode.classList.remove(\"selected\");\n    return true;\n}\n\n// Overridden by subclasses.\nTreeElement.prototype.onpopulate = function() { }\nTreeElement.prototype.onenter = function() { }\nTreeElement.prototype.ondelete = function() { }\nTreeElement.prototype.onspace = function() { }\nTreeElement.prototype.onattach = function() { }\nTreeElement.prototype.onexpand = function() { }\nTreeElement.prototype.oncollapse = function() { }\nTreeElement.prototype.ondblclick = function() { }\nTreeElement.prototype.onreveal = function() { }\n/** @param {boolean=} selectedByUser */\nTreeElement.prototype.onselect = function(selectedByUser) { }\n\n/**\n * @param {boolean} skipUnrevealed\n * @param {(TreeOutline|TreeElement)=} stayWithin\n * @param {boolean=} dontPopulate\n * @param {Object=} info\n * @return {TreeElement}\n */\nTreeElement.prototype.traverseNextTreeElement = function(skipUnrevealed, stayWithin, dontPopulate, info)\n{\n    if (!dontPopulate && this.hasChildren)\n        this.onpopulate();\n\n    if (info)\n        info.depthChange = 0;\n\n    var element = skipUnrevealed ? (this.revealed() ? this.children[0] : null) : this.children[0];\n    if (element && (!skipUnrevealed || (skipUnrevealed && this.expanded))) {\n        if (info)\n            info.depthChange = 1;\n        return element;\n    }\n\n    if (this === stayWithin)\n        return null;\n\n    element = skipUnrevealed ? (this.revealed() ? this.nextSibling : null) : this.nextSibling;\n    if (element)\n        return element;\n\n    element = this;\n    while (element && !element.root && !(skipUnrevealed ? (element.revealed() ? element.nextSibling : null) : element.nextSibling) && element.parent !== stayWithin) {\n        if (info)\n            info.depthChange -= 1;\n        element = element.parent;\n    }\n\n    if (!element)\n        return null;\n\n    return (skipUnrevealed ? (element.revealed() ? element.nextSibling : null) : element.nextSibling);\n}\n\n/**\n * @param {boolean} skipUnrevealed\n * @param {boolean=} dontPopulate\n * @return {TreeElement}\n */\nTreeElement.prototype.traversePreviousTreeElement = function(skipUnrevealed, dontPopulate)\n{\n    var element = skipUnrevealed ? (this.revealed() ? this.previousSibling : null) : this.previousSibling;\n    if (!dontPopulate && element && element.hasChildren)\n        element.onpopulate();\n\n    while (element && (skipUnrevealed ? (element.revealed() && element.expanded ? element.children[element.children.length - 1] : null) : element.children[element.children.length - 1])) {\n        if (!dontPopulate && element.hasChildren)\n            element.onpopulate();\n        element = (skipUnrevealed ? (element.revealed() && element.expanded ? element.children[element.children.length - 1] : null) : element.children[element.children.length - 1]);\n    }\n\n    if (element)\n        return element;\n\n    if (!this.parent || this.parent.root)\n        return null;\n\n    return this.parent;\n}\n\nTreeElement.prototype.isEventWithinDisclosureTriangle = function(event)\n{\n    // FIXME: We should not use getComputedStyle(). For that we need to get rid of using ::before for disclosure triangle. (http://webk.it/74446) \n    var paddingLeftValue = window.getComputedStyle(this._listItemNode).paddingLeft;\n    var computedLeftPadding = parseFloat(paddingLeftValue, 10);\n    var left = this._listItemNode.totalOffsetLeft() + computedLeftPadding;\n    return event.pageX >= left && event.pageX <= left + this.arrowToggleWidth && this.hasChildren;\n}\n","/home/travis/build/npmtest/node-npmtest-node-inspector/node_modules/node-inspector/front-end-node/NodeInspectorOverrides.js":"/*jshint browser:true, nonew:false*/\n/*global WebInspector, Runtime, InspectorFrontendHost, InspectorBackend, InspectorBackendClass*/\nWebInspector.NodeInspectorOverrides = function() {\n  this._overridenStrings = {\n    'Developer Tools - %s': 'Node Inspector - %s',\n    '(no domain)': '(core modules)'\n  };\n  this._overrideProtocolJsonPath();\n  this._overrideMainScriptType();\n  this._overrideUIStrings();\n  this._overrideWebSocketCreate();\n\n  this._setWorkerTitle();\n\n  this._mergeConnectionQueryParams();\n\n  this._openMainScriptOnStartup();\n\n  this._enableDebuggerUINotifications();\n};\n\nWebInspector.NodeInspectorOverrides.prototype = {\n  _overrideProtocolJsonPath: function() {\n    InspectorBackend.orig_loadFromJSONIfNeeded = InspectorBackend.loadFromJSONIfNeeded;\n    InspectorBackend.loadFromJSONIfNeeded = function(url) {\n      if (url == '../protocol.json')\n        return this.orig_loadFromJSONIfNeeded('protocol.json');\n    };\n  },\n  _overrideMainScriptType: function() {\n    WebInspector.ResourceTreeModel.prototype.orig_createResourceFromFramePayload =\n      WebInspector.ResourceTreeModel.prototype._createResourceFromFramePayload;\n\n    WebInspector.ResourceTreeModel.prototype._createResourceFromFramePayload =\n      function(frame, url, type, mimeType) {\n        // Force Script type for all node frames.\n        // Front-end assigns Document type (i.e. HTML) to our main script file.\n        if (frame._isNodeInspectorScript) {\n          type = WebInspector.resourceTypes.Script;\n        }\n\n        return this.orig_createResourceFromFramePayload(frame, url, type, mimeType);\n      };\n  },\n\n  _overrideUIStrings: function() {\n    var overridenStrings = this._overridenStrings;\n    WebInspector.orig_UIString = WebInspector.UIString;\n    WebInspector.UIString = function(string, vararg) {\n      var args = Array.prototype.slice.call(arguments);\n      args[0] = overridenStrings[string] || string;\n      return this.orig_UIString.apply(this, args);\n    };\n  },\n\n  _overrideWebSocketCreate: function() {\n    InspectorBackendClass.WebSocketConnection.origCreate =\n      InspectorBackendClass.WebSocketConnection.Create;\n\n    InspectorBackendClass.WebSocketConnection.Create = function(url, onConnectionReady) {\n      var args = Array.prototype.slice.call(arguments);\n      // If front-end is loaded via HTTPS, WebSocket protocol needs to be\n      // changed to WSS. Otherwise the browser will block the connection.\n      var protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\n      args[0] = url.replace(/^ws:/, protocol);\n      this.origCreate.apply(this, args);\n    };\n  },\n\n  _setWorkerTitle: function() {\n    // Front-end uses `eval location.href` to get url of inspected page\n    // This does not work in node.js from obvious reasons, and cause\n    // a 'null' message to be printed in front-end console.\n    // Since Preferences.applicationTitle does not include inspected url,\n    // we can return arbitrary string as inspected URL.\n    WebInspector.WorkerTargetManager.prototype._calculateWorkerInspectorTitle = function() {\n      InspectorFrontendHost.inspectedURLChanged('');\n    };\n  },\n\n  _openMainScriptOnStartup: function() {\n    WebInspector.targetManager.addModelListener(\n      WebInspector.ResourceTreeModel,\n      WebInspector.ResourceTreeModel.EventTypes.CachedResourcesLoaded,\n      showMainAppFile,\n      null\n    );\n  },\n\n  _mergeConnectionQueryParams: function() {\n    var params = Runtime._queryParamsObject;\n    params['port'] = params['port'] || '5858';\n    params['ws'] = params['ws'] || (location.host + location.pathname);\n    if (params['host']) {\n        params['ws'] += /\\?/.test(params['ws']) ? '&' : '?';\n        params['ws'] += 'host=' + params['host'];\n    }\n    params['ws'] += /\\?/.test(params['ws']) ? '&' : '?';\n    params['ws'] += 'port=' + params['port'];\n  },\n\n  _notifications: [],\n\n  _enableDebuggerUINotifications: function() {\n    if (!window.Notification) return;\n\n    function closeAllNotifications() {\n      this._notifications.forEach(closeNotification);\n      this._notifications = [];\n    }\n\n    function clickOnNotification(event) {\n      closeNotification(this);\n      window.focus();\n    }\n\n    function closeNotification(notification) {\n      notification.removeEventListener('click', clickOnNotification);\n      notification.close();\n    }\n\n    Notification.requestPermission(function (permission) {\n      if (permission !== 'granted') return;\n\n      WebInspector.targetManager.addModelListener(\n        WebInspector.DebuggerModel,\n        WebInspector.DebuggerModel.Events.DebuggerPaused,\n        processDebuggerPaused,\n        this\n      );\n\n      window.addEventListener('click', closeAllNotifications.bind(this));\n      window.addEventListener('focus', closeAllNotifications.bind(this));\n    }.bind(this));\n\n    function setMessageTitle(message, reason, currentFrame) {\n      switch (reason) {\n        case 'exception':\n          message.title = 'Exception caught';\n          break;\n        default:\n          message.title = 'Debugger paused';\n          break;\n      }\n    }\n\n    function setMessageHeader(message, reason, currentFrame) {\n      if (!currentFrame) return;\n\n      switch (reason) {\n        case 'exception':\n          message.header = 'Exception caught';\n          break;\n        default:\n          message.header = 'Breakpoint caught';\n          break;\n      }\n    }\n\n    function setMessageFrameInfo(message, reason, currentFrame) {\n      if (!currentFrame) return;\n\n      var lineNumber = currentFrame._location.lineNumber;\n      var columnNumber = currentFrame._location.columnNumber;\n      var scriptId = currentFrame._location.scriptId;\n      var sourceURL = currentFrame._script.sourceURL;\n      var sourceMapForId = currentFrame._target._sourceMapForScriptId;\n\n      if (sourceMapForId[scriptId] != null) {\n        var sourceMapEntry = sourceMapForId[scriptId].findEntry(lineNumber, columnNumber);\n        sourceURL = sourceMapEntry[2];\n        lineNumber = sourceMapEntry[3];\n        columnNumber = sourceMapEntry[4];\n      }\n\n      if (sourceURL) {\n        sourceURL = sourceURL.substr(sourceURL.lastIndexOf('/')+1);\n      }\n\n      message.frameInfo = ' in module ' +\n        (sourceURL || '(' + scriptId + ')') +\n        ' at line ' + (lineNumber + 1) +\n        ' column ' + columnNumber;\n    }\n\n    function processDebuggerPaused(event) {\n      if (document.hasFocus()) return;\n\n      var reason = event.data.reason;\n      var currentFrame = event.data.callFrames[0];\n\n      var message = {\n        title: '',\n        header: '',\n        frameInfo: ''\n      };\n\n      setMessageTitle(message, reason, currentFrame);\n      setMessageHeader(message, reason, currentFrame);\n      setMessageFrameInfo(message, reason, currentFrame);\n\n      var notification = new Notification(message.title, {\n        tag: location.href,\n        body: [\n          message.header,\n          message.frameInfo\n        ].join(''),\n        icon: 'favicon.ico'\n      });\n\n      notification.addEventListener('click', clickOnNotification);\n\n      this._notifications.push(notification);\n    }\n  }\n};\n\nnew WebInspector.NodeInspectorOverrides();\n\n\nfunction showMainAppFile() {\n  WebInspector.inspectorView.showPanel('sources').then(function(panel) {\n    var fileTabs = panel._sourcesView._editorContainer._files;\n\n    if (Object.keys(fileTabs).length > 0){\n      // Some files are already opened - do not change user's workspace\n      return;\n    }\n\n    var uiSourceCodes = getAllUiSourceCodes();\n    var uriToShow = WebInspector.inspectedPageURL;\n\n    for (var i in uiSourceCodes) {\n      if (uiSourceCodes[i].url !== uriToShow) continue;\n      panel.showUISourceCode(uiSourceCodes[i]);\n      return true;\n    }\n\n    console.error('Cannot show the main application file ', uriToShow);\n  });\n}\n\nfunction getAllUiSourceCodes() {\n  // Based on FilteredItemSectionDialog.js > SelectUISourceCodeDialog()\n  var projects = WebInspector.workspace.projects();\n  var uiSourceCodes = [];\n  var projectFiles;\n\n  for (var i = 0; i < projects.length; ++i) {\n    projectFiles = projects[i]\n      .uiSourceCodes()\n      .filter(nameIsNotEmpty);\n    uiSourceCodes = uiSourceCodes.concat(projectFiles);\n  }\n\n  return uiSourceCodes;\n\n  function nameIsNotEmpty(p) {\n    return p.name();\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-node-inspector/node_modules/node-inspector/lib/BreakEventHandler.js":"var convert = require('./convert'),\n    async = require('async'),\n    CallFramesProvider = require('./CallFramesProvider').CallFramesProvider;\n\n/**\n * @param {Object} config\n * @param {FrontendClient} frontendClient\n * @param {DebuggerClient} debuggerClient\n * @param {ScriptManager} scriptManager\n * @param {InjectorClient} injectorClient\n * @constructor\n */\nfunction BreakEventHandler(config, session) {\n  this._config = config;\n  this._session = session;\n  this._frontendClient = session.frontendClient;\n  this._debuggerClient = session.debuggerClient;\n  this._injectorClient = session.injectorClient;\n  this._scriptManager = session.scriptManager;\n  this._callFramesProvider = new CallFramesProvider(config, session);\n\n  this._debuggerClient.on('break', this._onBreak.bind(this));\n  this._debuggerClient.on('exception', this._onBreak.bind(this));\n}\n\nvar callbackForNextBreak;\n\nObject.defineProperties(BreakEventHandler.prototype, {\n  /** @type {Number} */\n  continueToLocationBreakpointId: {\n    writable: true,\n    value: null\n  },\n\n  /** @type {function(eventData)} */\n  callbackForNextBreak: {\n    get: function() { return callbackForNextBreak; },\n    set: function(value) {\n      if (value && callbackForNextBreak)\n        throw new Error('Cannot set multiple callbacks for the next break.');\n      callbackForNextBreak = value;\n    }\n  }\n});\n\n// If we started with --debug-brk, first onBreak should get the `require` handle, so we should detect\n// if it is --debug-brk first\n\nBreakEventHandler.prototype._handleOnFirstBreak = function(cb) {\n  var self = this;\n  var debuggerClient = this._debuggerClient;\n  var injectorClient = this._injectorClient;\n  var isBreak = debuggerClient.target && debuggerClient.target.break === true;\n  if (this._firstBreakHandled || !isBreak) {\n    return cb();\n  }\n\n  if (isBreak) {\n    debuggerClient.request('evaluate', {\n      expression: 'process._require = require',\n      global: false,\n    }, function(err, response) {\n      if (err) {\n        cb(err);\n      } else {\n        self._firstBreakHandled = true;\n        // prevent injecting again\n        injectorClient._injected = true;\n        async.waterfall([\n          injectorClient._inject.bind(injectorClient),\n          injectorClient._onInjection.bind(injectorClient),\n        ], cb);\n      }\n    });\n  }\n};\n\nBreakEventHandler.prototype._onBreak = function(obj) {\n  // ignore breakpoint when injecting\n  if(obj.script.name === 'bootstrap_node.js' && !this._injectorClient._injected) {\n    return;\n  }\n  async.waterfall([\n    this._handleOnFirstBreak.bind(this),\n    this._handleInjectorClientBreak.bind(this, obj),\n    this._resolveScriptSource.bind(this, obj),\n    this._handleIgnoreBreakpoint.bind(this, obj),\n    this._handleCallbackForNextBreak.bind(this, obj),\n    this._handleContinueToLocation.bind(this, obj),\n    this.sendBacktraceToFrontend.bind(this, obj)\n  ], function(err) {\n    if (err && err !== true) {\n      this._frontendClient.sendLogToConsole('error', err);\n    }\n  }.bind(this));\n};\n\nBreakEventHandler.prototype._handleInjectorClientBreak = function(obj, cb) {\n  this._injectorClient.tryHandleDebuggerBreak(obj.invocationText, cb);\n};\n\nBreakEventHandler.prototype._resolveScriptSource = function(obj, cb) {\n  this._scriptManager.resolveScriptById(obj.script.id, cb);\n};\n\nBreakEventHandler.prototype._handleIgnoreBreakpoint = function(obj, source, cb) {\n  var ignore = false;\n\n  // Source is undefined when the breakpoint was in code eval()-ed via\n  // console or eval()-ed internally by node inspector.\n  // We could send backtrace in such case, but that isn't working well now.\n  // V8 is reusing the same scriptId for multiple eval() calls and DevTools\n  // front-end does not update the displayed source code when a content\n  // of a script changes.\n  // The following solution - ignore the breakpoint and resume the\n  // execution - should be good enough in most cases.\n  if (!source || source.hidden) {\n    ignore = true;\n  }\n\n  // In the case of \"break on uncaught exception\" triggered by\n  // \"TypeError: undefined is not a function\", the exception is\n  // thrown by a V8 builtin CALL_NON_FUNCTION defined in\n  // v8/src/runtime.js. Thus, the script id of the event is not know\n  // by Node Inspector, but the break even must not be ignored.\n  // See https://github.com/node-inspector/node-inspector/issues/344\n  if (obj.exception) {\n    ignore = false;\n  }\n\n  if (ignore) {\n    this._debuggerClient.request('continue', { stepaction: 'out' });\n  }\n\n  cb(ignore);\n};\n\nBreakEventHandler.prototype._handleCallbackForNextBreak = function(obj, cb) {\n  if (!this.callbackForNextBreak) return cb(null);\n\n  var callbackForNextBreak = this.callbackForNextBreak;\n  this.callbackForNextBreak = null;\n  callbackForNextBreak(obj);\n\n  cb(true);\n};\n\nBreakEventHandler.prototype._handleContinueToLocation = function(obj, cb) {\n  if (this.continueToLocationBreakpointId == null) return cb(null);\n\n  this._debuggerClient.clearBreakpoint(\n    this.continueToLocationBreakpointId,\n    function(err, result) {\n      if (err)\n        this._frontendClient.sendLogToConsole('warning', err);\n      else\n        this.continueToLocationBreakpointId = null;\n\n      cb(true);\n    }.bind(this)\n  );\n};\n\n/**\n * @param {function(error, response)} callback\n */\nBreakEventHandler.prototype.fetchCallFrames = function(callback) {\n  this._callFramesProvider.fetchCallFrames(callback);\n};\n\n/**\n * @param {Object} exception\n * @param {Array.<number>} hitBreakpoints\n */\nBreakEventHandler.prototype.sendBacktraceToFrontend = function(obj, cb) {\n  obj = obj || {\n    exception: false,\n    hitBreakpoints: false\n  };\n\n  cb = cb || function() {};\n\n  var exception = obj.exception,\n      hitBreakpoints = obj.hitBreakpoints;\n\n  this.fetchCallFrames(function(error, result) {\n    if (error) return cb(error);\n\n    this._frontendClient.sendEvent(\n      'Debugger.paused',\n      {\n        callFrames: result,\n        reason: exception ? 'exception' : 'other',\n        data: exception ? convert.v8RefToInspectorObject(exception) : null,\n        hitBreakpoints: hitBreakpoints\n      });\n\n    cb(null);\n  }.bind(this));\n};\n\nexports.BreakEventHandler = BreakEventHandler;\n","/home/travis/build/npmtest/node-npmtest-node-inspector/node_modules/node-inspector/lib/convert.js":"exports.v8LocationToInspectorLocation = function(v8loc) {\n  return {\n    scriptId: v8loc.script_id.toString(),\n    lineNumber: v8loc.line,\n    columnNumber: v8loc.column\n  };\n};\n\n\n// Conversions between v8 file paths and node-inspector urls\n// Kind      Path            Url\n// UNIX      /dir/app.js     file:///dir/app.js\n// Windows   c:\\dir\\app.js   file:///C:/dir/app.js\n// UNC       \\\\SHARE\\app.js  file://SHARE/app.js\n\nexports.v8NameToInspectorUrl = function(v8name) {\n  if (!v8name || v8name === 'repl') {\n    // Call to `evaluate` from user-land creates a new script with undefined URL.\n    // REPL has null main script file and calls `evaluate` with `repl`\n    // as the file name.\n    //\n    // When we send an empty string as URL, front-end opens the source\n    // as VM-only script (named \"[VM] {script-id}\").\n    //\n    // The empty name of the main script file is displayed as \"(program)\".\n    return '';\n  }\n\n  if (/^\\//.test(v8name)) {\n    return 'file://' + v8name;\n  } else if (/^[a-zA-Z]:\\\\/.test(v8name)) {\n    return 'file:///' + v8name.replace(/\\\\/g, '/');\n  } else if (/^\\\\\\\\/.test(v8name)) {\n    return 'file://' + v8name.substring(2).replace(/\\\\/g, '/');\n  }\n\n  return v8name;\n};\n\nexports.inspectorUrlToV8Name = function(url, normalize) {\n  var path = normalize(url).replace(/^file:\\/\\//, '');\n  if (/^\\/[a-zA-Z]:\\//.test(path))\n    return path.substring(1).replace(/\\//g, '\\\\'); // Windows disk path\n  if (/^\\//.test(path))\n    return path; // UNIX-style\n  if (/^file:\\/\\//.test(url))\n    return '\\\\\\\\' + path.replace(/\\//g, '\\\\'); // Windows UNC path\n\n  return url;\n};\n\nexports.v8ScopeTypeToString = function(v8ScopeType) {\n  switch (v8ScopeType) {\n    case 0:\n      return 'global';\n    case 1:\n      return 'local';\n    case 2:\n      return 'with';\n    case 3:\n      return 'closure';\n    case 4:\n      return 'catch';\n    default:\n      return 'unknown';\n  }\n};\n\nexports.v8RefToInspectorObject = function(ref) {\n  var desc = '',\n      type = ref.type,\n      subtype,\n      size,\n      name,\n      objectId,\n      inspectorResult;\n\n  switch (type) {\n    case 'object':\n      name = /#<(\\w+)>/.exec(ref.text);\n      if (name && name.length > 1) {\n        desc = name[1];\n        if (desc === 'Array' || desc === 'Buffer') {\n          size = ref.properties.filter(function(p) { return /^\\d+$/.test(p.name);}).length;\n          desc += '[' + size + ']';\n          subtype = 'array';\n        }\n      } else if (ref.className === 'Date') {\n        desc = new Date(ref.value || NaN).toString();\n        subtype = 'date';\n      } else {\n        desc = ref.className || 'Object';\n      }\n      break;\n    case 'regexp':\n      type = 'object';\n      subtype = 'regexp';\n      desc = ref.text || '';\n      /*\n        We need to collect RegExp flags and append they to description,\n        or open issue in NodeJS same as 'RegExp text serialized without flags'\n      */\n      break;\n    case 'function':\n      desc = ref.text || 'function()';\n      break;\n    case 'error':\n      type = 'object';\n      desc = ref.text || 'Error';\n      break;\n    default:\n      desc = ref.text || '';\n      break;\n  }\n  if (desc.length > 100) {\n    desc = desc.substring(0, 100) + '\\u2026';\n  }\n\n  objectId = ref.handle;\n  if (objectId === undefined)\n    objectId = ref.ref;\n\n  inspectorResult = {\n    type: type,\n    subtype: subtype,\n    objectId: String(objectId),\n    className: ref.className,\n    description: desc\n  };\n\n  return inspectorResult;\n};\n\nexports.v8ObjectToInspectorProperties = function(obj, refs, options) {\n  var proto = obj.protoObject,\n      props = obj.properties || [],\n      ownProperties = options.ownProperties,\n      accessorPropertiesOnly = options.accessorPropertiesOnly;\n\n  props = props.map(function(prop) {\n    var ref = refs[prop.ref];\n    var inspectorProperty = {\n        name: String(prop.name),\n        writable: !(prop.attributes & 1 << 0),\n        enumerable: !(prop.attributes & 1 << 1),\n        configurable: !(prop.attributes & 1 << 2),\n        value: exports.v8ResultToInspectorResult(ref)\n      };\n    return inspectorProperty;\n  });\n\n  if (ownProperties && proto) {\n    proto = refs[proto.ref];\n    if (proto.type !== 'undefined') {\n      props.push({\n        name: '__proto__',\n        value: exports.v8RefToInspectorObject(proto),\n        writable: true,\n        configurable: true,\n        enumerable: false,\n        isOwn: true\n      });\n    }\n  }\n\n  props = props.filter(function(prop) {\n  /*\n    Node.js does not return get/set property descriptors now (v0.11.11),\n      therefore we can't fully implement 'accessorPropertiesOnly'.\n    See https://github.com/joyent/node/issues/7139\n  */\n    var isAccessorProperty = ('get' in prop || 'set' in prop);\n\n    return accessorPropertiesOnly ? isAccessorProperty : !isAccessorProperty;\n  });\n\n  return props;\n};\n\nexports.v8ErrorToInspectorError = function(message) {\n  var nameMatch = /^([^:]+):/.exec(message);\n\n  return {\n    type: 'object',\n    objectId: 'ERROR',\n    className: nameMatch ? nameMatch[1] : 'Error',\n    description: message\n  };\n};\n\nexports.v8ResultToInspectorResult = function(result) {\n  var subtype,\n      inspectorResult;\n  if (['object', 'function', 'regexp', 'error'].indexOf(result.type) > -1) {\n    return exports.v8RefToInspectorObject(result);\n  }\n\n  if (result.type == 'null') {\n    // workaround for the problem with front-end's setVariableValue\n    // implementation not preserving null type\n    result.value = null;\n    subtype = 'null';\n  }\n\n  inspectorResult = {\n    type: result.type,\n    subtype: subtype,\n    value: result.value,\n    description: String(result.value)\n  };\n\n  return inspectorResult;\n};\n\nexports.inspectorValueToV8Value = function(value) {\n  if (value.value === undefined && value.objectId === undefined)\n    return { type: 'undefined' };\n  if (value.objectId) {\n    return { handle: Number(value.objectId) };\n  }\n  return value;\n};\n\nexports.v8FunctionLookupToFunctionDetails = function(handleData) {\n  return {\n    details: {\n      location: {\n        scriptId: String(handleData.scriptId),\n        lineNumber: handleData.line,\n        columnNumber: handleData.column\n      },\n      name: handleData.name || handleData.inferredName,\n\n      // There is a list of scope ids in responseBody.scopes, but not scope\n      // details :( // We need to issue `scopes` request to fetch scopes\n      // details, but we don't have frame number where the function was defined.\n      // Let's leave the scopeChain empty for now.\n      scopeChain: []\n    }\n  };\n};\n\nexports.v8ScriptIdToInspectorId = function(scriptId) {\n  return String(scriptId);\n};\n\nexports.inspectorScriptIdToV8Id = function(scriptId) {\n  return Number(scriptId);\n};\n","/home/travis/build/npmtest/node-npmtest-node-inspector/node_modules/node-inspector/lib/CallFramesProvider.js":"var async = require('async'),\n    convert = require('./convert.js');\n\nvar SCOPE_ID_MATCHER = /^scope:(\\d+):(\\d+)$/;\n\n/**\n * @param {Object} config\n * @param {DebuggerClient} debuggerClient\n */\nfunction CallFramesProvider(config, session) {\n  this._config = config;\n  this._debuggerClient = session.debuggerClient;\n}\n\nCallFramesProvider.prototype = {\n\n  fetchCallFrames: function(handleResponse) {\n    this._debuggerClient.request(\n      'backtrace',\n      {\n        inlineRefs: true,\n        fromFrame: 0,\n        toFrame: this._config.stackTraceLimit\n      },\n      function(err, responseBody, responseRefs) {\n        if (err) {\n          handleResponse(err);\n          return;\n        }\n\n        this._convertBacktraceToCallFrames(responseBody, responseRefs, handleResponse);\n      }.bind(this));\n  },\n\n  _convertBacktraceToCallFrames: function(backtraceResponseBody, backtrackResponseRefs, handleResponse) {\n    var debuggerFrames = backtraceResponseBody.frames || [];\n\n    async.map(\n      debuggerFrames,\n      this._convertDebuggerFrameToInspectorFrame.bind(this, backtrackResponseRefs),\n      handleResponse);\n  },\n\n  _convertDebuggerFrameToInspectorFrame: function(backtrackResponseRefs, frame, done) {\n    var scopeChain = frame.scopes.map(function(scope) {\n      return {\n        object: {\n          type: 'object',\n          objectId: 'scope:' + frame.index + ':' + scope.index,\n          className: 'Object',\n          description: 'Object'\n        },\n        type: convert.v8ScopeTypeToString(scope.type)\n      };\n    });\n\n    done(null, {\n      callFrameId: frame.index.toString(),\n      functionName: frame.func.inferredName || frame.func.name,\n      location: {\n        scriptId: convert.v8ScriptIdToInspectorId(frame.func.scriptId),\n        lineNumber: frame.line,\n        columnNumber: frame.column\n      },\n      scopeChain: scopeChain,\n      this: convert.v8RefToInspectorObject(frame.receiver)\n    });\n  },\n\n  isScopeId: function(objectId) {\n    return SCOPE_ID_MATCHER.test(objectId);\n  },\n\n  resolveScopeId: function(objectId, callback) {\n    var scopeIdMatch = SCOPE_ID_MATCHER.exec(objectId);\n    if (!scopeIdMatch) throw new Error('Invalid scope id \"' + objectId + '\"');\n    this._debuggerClient.request(\n      'scope',\n      {\n        number: Number(scopeIdMatch[2]),\n        frameNumber: Number(scopeIdMatch[1])\n      },\n      function(err, result) {\n        if (err)\n          callback(err);\n        else\n          callback(null, result.object.ref);\n      });\n  }\n};\n\nexports.CallFramesProvider = CallFramesProvider;\n","/home/travis/build/npmtest/node-npmtest-node-inspector/node_modules/node-inspector/lib/ConsoleAgent.js":"var convert = require('./convert');\n\nvar injection = require.resolve('./Injections/ConsoleAgent');\n\n/**\n * @param {Object} config\n * @param {DebuggerClient} debuggerClient\n * @param {FrontendClient} frontendClient\n * @param {InjectorClient} injectorClient\n * @param {ConsoleClient} consoleClient\n * @constructor\n */\nfunction ConsoleAgent(config, session) {\n  try {\n    this._noInject = config.inject === false || config.inject.console === false;\n  } catch (e) {\n    this._noInject = false;\n  }\n\n  this._injected = false;\n  this._debuggerClient = session.debuggerClient;\n  this._frontendClient = session.frontendClient;\n  this._injectorClient = session.injectorClient;\n  this._consoleClient = session.consoleClient;\n  this._translateCommandToInjection(\n    'clearMessages'\n  );\n\n  if (!this._noInject) this._injectorClient.on('inject', this._inject.bind(this));\n}\n\nConsoleAgent.prototype._inject = function() {\n  this._translateEventToFrontend(\n    'messageAdded',\n    'messagesCleared'\n  );\n\n  this._injectorClient.injection(\n    function(require, debug, options) {\n      require(options.injection)(require, debug, options);\n    },\n    {\n      injection: injection\n    },\n    function(error, result) {\n      this._injected = !error;\n\n      if (error) return this._frontendClient.sendLogToConsole('error', error.message || error);\n    }.bind(this)\n  );\n};\n\n/**\n * @param {...string} eventNames\n*/\nConsoleAgent.prototype._translateEventToFrontend = function(eventNames) {\n  Array.prototype.forEach.call(arguments, function(event) {\n    event = 'Console.' + event;\n    this._debuggerClient.on(event, function(message) {\n      if (event == 'Console.messageAdded') {\n        message.message.parameters = message.message.parameters.map(function(ref) {\n          this._consoleClient.convertHandleToConsoleHandle(ref, message.message.id);\n          return convert.v8ResultToInspectorResult(ref);\n        }, this);\n      }\n      this._frontendClient.sendEvent(event, message);\n    }.bind(this));\n  }, this);\n};\n\n/**\n * @param {...string} commandNames\n*/\nConsoleAgent.prototype._translateCommandToInjection = function(commandNames) {\n  Array.prototype.forEach.call(arguments, function(command) {\n    this[command] = function(params, done) {\n      this._debuggerClient.request('Console.' + command, params, done);\n    };\n  }, this);\n};\n\nmodule.exports.ConsoleAgent = ConsoleAgent;\n","/home/travis/build/npmtest/node-npmtest-node-inspector/node_modules/node-inspector/lib/ConsoleClient.js":"//console:messageId:refHandle\nvar CONSOLE_ID_MATCHER = /^console:(\\d+):(\\d+)$/;\n\nfunction ConsoleClient(config, session) {\n  this._debuggerClient = session.debuggerClient;\n  this._frontendClient = session.frontendClient;\n}\n\nConsoleClient.prototype.isConsoleId = function(objectId) {\n  return CONSOLE_ID_MATCHER.test(objectId);\n};\n\nConsoleClient.prototype.lookupConsoleId = function(objectId, done) {\n  var matchedId = CONSOLE_ID_MATCHER.exec(objectId);\n  var messageId = matchedId[1];\n  this._debuggerClient.request(\n    'Console._lookupConsoleId', \n    { \n      messageId: messageId,\n      objectId: matchedId[2]\n    },\n    function(error, lookupBody, lookupRefs) {\n      if (error) return done(error);\n      \n      Object.keys(lookupRefs).forEach(function(key) {\n        this.convertHandleToConsoleHandle(lookupRefs[key], messageId);\n      }, this);\n      done(null, lookupBody, lookupRefs);\n    }.bind(this)\n  );\n};\n\nConsoleClient.prototype.convertHandleToConsoleHandle = function(ref, messageId) {\n  if (ref.handle !== undefined) {\n    ref.handle = 'console:' + messageId + ':' + ref.handle;\n  }\n};\n\nexports.ConsoleClient = ConsoleClient;\n","/home/travis/build/npmtest/node-npmtest-node-inspector/node_modules/node-inspector/lib/DebuggerAgent.js":"// node-inspector version of on webkit-inspector/DebuggerAgent.cpp\n\nvar convert = require('./convert.js'),\n  semver = require('semver'),\n  format = require('util').format,\n  path = require('path'),\n  async = require('async'),\n  ScriptFileStorage = require('./ScriptFileStorage').ScriptFileStorage;\n\n/**\n * @param {{saveLiveEdit,preload}} config\n * @param {FrontendClient} frontendClient\n * @param {DebuggerClient} debuggerClient\n * @param {BreakEventHandler} breakEventHandler\n * @param {ScriptManager} scriptManager\n * @param {InjectorClient} injectorClient\n * @constructor\n */\nfunction DebuggerAgent(config, session) {\n  this._enabled = false;\n  this._saveLiveEdit = config.saveLiveEdit;\n  this._frontendClient = session.frontendClient;\n  this._debuggerClient = session.debuggerClient;\n  this._breakEventHandler = session.breakEventHandler;\n  this._scriptManager = session.scriptManager;\n  this._injectorClient = session.injectorClient;\n  this._consoleClient = session.consoleClient;\n  this._heapProfilerClient = session.heapProfilerClient;\n  this._scriptStorage = new ScriptFileStorage(config, session);\n}\n\nDebuggerAgent.prototype = {\n  canSetScriptSource: function(params, done) {\n    done(null, { result: true });\n  },\n\n  enable: function(params, done) {\n    var onConnect = function() {\n      done();\n\n      if (this._enabled) return;\n      this._enabled = true;\n\n      this._onDebuggerConnect();\n    }.bind(this);\n\n    if (this._debuggerClient.isReady) {\n      process.nextTick(onConnect);\n    } else {\n      this._debuggerClient.on('connect', onConnect);\n      this._debuggerClient.connect();\n    }\n  },\n\n  _onDebuggerConnect: function() {\n    async.waterfall([\n      // Remove all existing breakpoints because:\n      // 1) front-end inspector cannot restore breakpoints from debugger anyway\n      // 2) all breakpoints were disabled when the previous debugger-client\n      //    disconnected from the debugged application\n      // 3) Inject custom debugger commands in app\n      // 4) If we started with --debug-brk we can't use custom debugger commands on first break.\n      //    We need to reallocate debug context - restart frame and step into.\n      this._removeAllBreakpoints.bind(this),\n      this._reloadScripts.bind(this),\n      this._tryConnectInjector.bind(this),\n    ]);\n  },\n\n  _removeAllBreakpoints: function(done) {\n    this._debuggerClient.request(\n      'listbreakpoints',\n      {},\n      function(err, response) {\n        if (err) {\n          console.log('Warning: cannot remove old breakpoints. %s', err);\n          done();\n          return;\n        }\n\n        function removeOneBreakpoint(bp, next) {\n          this._debuggerClient.clearBreakpoint(\n            bp.number,\n            function(error) {\n              if (error)\n                console.log(\n                  'Warning: cannot remove old breakpoint %d. %s',\n                  bp.number,\n                  error\n                );\n              next();\n            }\n          );\n        }\n\n        async.eachSeries(\n          response.breakpoints,\n          removeOneBreakpoint.bind(this),\n          done\n        );\n      }.bind(this)\n    );\n  },\n\n  _reloadScripts: function(done) {\n    this._scriptManager.reset();\n    this._debuggerClient.request(\n      'scripts',\n      {\n        includeSource: true,\n        types: 4\n      },\n      function handleScriptsResponse(err, result) {\n        if (err) {\n          done(err);\n          return;\n        }\n\n        result.forEach(function(script) {\n          this._scriptManager.addScript(script);\n        }, this);\n        done();\n      }.bind(this)\n    );\n  },\n\n  _tryConnectInjector: function(done) {\n    this._injectorClient.inject(done);\n  },\n\n  _restartFrameIfPaused: function(done) {\n    if (this._debuggerClient.isRunning) return done();\n\n    this.restartFrame({ callFrameId: 0 }, function(error, result) {\n      if (error) return done(error);\n\n      result = result.result || result;\n      if (result.stack_update_needs_step_in)\n        this.stepInto({}, done);\n      else\n        done(error);\n    }.bind(this));\n  },\n\n  _sendBacktraceIfPaused: function(done) {\n    if (!this._debuggerClient.isRunning) {\n      this._breakEventHandler.sendBacktraceToFrontend(null);\n    }\n    done();\n  },\n\n  disable: function(params, done) {\n    done();\n  },\n\n  resume: function(params, done) {\n    this._sendContinue(undefined, done);\n  },\n\n  _sendContinue: function(stepAction, done) {\n    var args = stepAction ? { stepaction: stepAction } : undefined;\n    if (args) {\n      args.stepcount = 1;\n    }\n    this._debuggerClient.request('continue', args, function(error, result) {\n      done(error);\n      if (!error)\n        this._frontendClient.sendEvent('Debugger.resumed');\n    }.bind(this));\n  },\n\n  pause: function(params, done) {\n    this._debuggerClient.request('suspend', {}, function(error, result) {\n      done(error);\n      if (!error) {\n        this._breakEventHandler.sendBacktraceToFrontend(null);\n      }\n    }.bind(this));\n  },\n\n  stepOver: function(params, done) {\n    this._sendContinue('next', done);\n  },\n\n  stepInto: function(params, done) {\n    this._sendContinue('in', done);\n  },\n\n  stepOut: function(params, done) {\n    this._sendContinue('out', done);\n  },\n\n  continueToLocation: function(params, done) {\n    var requestParams = {\n      type: 'scriptId',\n      target: convert.inspectorScriptIdToV8Id(params.location.scriptId),\n      line: params.location.lineNumber,\n      column: params.location.columnNumber\n    };\n\n    this._debuggerClient.request('setbreakpoint', requestParams, function(error, response) {\n      if (error != null) {\n        done(error);\n        return;\n      }\n\n      this._breakEventHandler.\n        continueToLocationBreakpointId = response.breakpoint;\n\n      this._debuggerClient.request('continue', undefined, function(error, response) {\n        done(error);\n      });\n    }.bind(this));\n  },\n\n  getScriptSource: function(params, done) {\n    this._scriptManager.getScriptSourceById(\n      Number(params.scriptId),\n      function(err, source) {\n        if (err) return done(err);\n        return done(null, { scriptSource: source });\n      }\n    );\n  },\n\n  setScriptSource: function(params, done) {\n    this._debuggerClient.request(\n      'changelive',\n      {\n        script_id: convert.inspectorScriptIdToV8Id(params.scriptId),\n        new_source: params.scriptSource,\n        preview_only: false\n      },\n      function(err, response) {\n        this._handleChangeLiveOrRestartFrameResponse(done, err, response);\n        this._persistScriptChanges(params.scriptId, params.scriptSource);\n      }.bind(this)\n    );\n  },\n\n  _handleChangeLiveOrRestartFrameResponse: function(done, err, response) {\n    if (err) {\n      done(err);\n      return;\n    }\n\n    var frontendClient = this._frontendClient;\n    var breakEventHandler = this._breakEventHandler;\n\n    function sendResponse(callframes) {\n      done(\n        null,\n        {\n          callFrames: callframes || [],\n          result: response.result\n        }\n      );\n    }\n\n    function sendResponseWithCallStack() {\n      breakEventHandler.fetchCallFrames(function(err, response) {\n        var callframes = [];\n        if (err) {\n          frontendClient.sendLogToConsole(\n            'error',\n            'Cannot update stack trace after a script changed: ' + err);\n        } else {\n          callframes = response;\n        }\n        sendResponse(callframes);\n      });\n    }\n\n    var result = response.result;\n    if (result.stack_modified && !result.stack_update_needs_step_in)\n      sendResponseWithCallStack();\n    else\n      sendResponse();\n  },\n\n  _persistScriptChanges: function(scriptId, newSource) {\n    if (!this._saveLiveEdit) {\n      this._warn(\n        'Saving of live-edit changes back to source files is disabled by configuration.\\n' +\n          'Change the option \"saveLiveEdit\" in config.json to enable this feature.'\n      );\n      return;\n    }\n\n    var source = this._scriptManager.findScriptByID(scriptId);\n    if (!source) {\n      this._warn('Cannot save changes to disk: unknown script id %s', scriptId);\n      return;\n    }\n\n    var scriptFile = source.v8name;\n    if (!scriptFile || scriptFile.indexOf(path.sep) == -1) {\n      this._warn(\n        'Cannot save changes to disk: script id %s \"%s\" was not loaded from a file.',\n        scriptId,\n        scriptFile || 'null'\n      );\n      return;\n    }\n\n    this._scriptStorage.save(scriptFile, newSource, function(err) {\n      if (err) {\n        this._warn('Cannot save changes to disk. %s', err);\n      }\n    }.bind(this));\n  },\n\n  _warn: function() {\n    this._frontendClient.sendLogToConsole(\n      'warning',\n      format.apply(this, arguments)\n    );\n  },\n\n  setPauseOnExceptions: function(params, done) {\n    var args = [\n      { type: 'all', enabled: params.state == 'all' },\n      { type: 'uncaught', enabled: params.state == 'uncaught' }\n    ];\n\n    async.eachSeries(\n      args,\n      function(arg, next) {\n        this._debuggerClient.request('setexceptionbreak', arg, next);\n      }.bind(this),\n      done);\n  },\n\n  setBreakpointByUrl: function(params, done) {\n    if (params.urlRegex !== undefined) {\n      // DevTools protocol defines urlRegex parameter,\n      // but the parameter is not used by the front-end.\n      done('Error: setBreakpointByUrl using urlRegex is not implemented.');\n      return;\n    }\n\n    var target = convert.inspectorUrlToV8Name(params.url,\n      this._scriptManager.normalizeName.bind(this._scriptManager));\n\n    var requestParams = {\n      type: 'script',\n      target: target,\n      line: params.lineNumber,\n      column: params.columnNumber,\n      condition: params.condition\n    };\n\n    this._debuggerClient.request('setbreakpoint', requestParams, function(error, response) {\n      if (error != null) {\n        done(error);\n        return;\n      }\n\n      done(null, {\n        breakpointId: response.breakpoint.toString(),\n        locations: response.actual_locations.map(convert.v8LocationToInspectorLocation)\n      });\n    });\n  },\n\n  removeBreakpoint: function(params, done) {\n    this._debuggerClient.clearBreakpoint(\n      params.breakpointId,\n      function(error, response) {\n        done(error, null);\n      }\n    );\n  },\n\n  setBreakpointsActive: function(params, done) {\n    this._debuggerClient.request('listbreakpoints', {}, function(error, response) {\n      if (error) {\n        done(error);\n        return;\n      }\n\n      function setBreakpointState(bp, next) {\n        var req = { breakpoint: bp.number, enabled: params.active };\n        this._debuggerClient.request('changebreakpoint', req, next);\n      }\n\n      async.eachSeries(response.breakpoints, setBreakpointState.bind(this), done);\n    }.bind(this));\n  },\n\n  setOverlayMessage: function(params, done) {\n    done();\n  },\n\n  evaluateOnCallFrame: function(params, done) {\n    var self = this;\n    var expression = params.expression;\n    var frame = Number(params.callFrameId);\n\n    self._debuggerClient.request(\n      'evaluate',\n      {\n        expression: params.expression,\n        frame: frame\n      },\n      function(err, result) {\n        // Errors from V8 are actually just messages, so we need to fill them out a bit.\n        if (err) {\n          err = convert.v8ErrorToInspectorError(err);\n        }\n\n        done(null, {\n          result: err || convert.v8ResultToInspectorResult(result),\n          wasThrown: !!err\n        });\n      }\n    );\n  },\n\n  getFunctionDetails: function(params, done) {\n    var handle = params.functionId;\n    var callback = function(error, responseBody) {\n      if (error) {\n        done(error);\n      } else {\n        done(null, convert.v8FunctionLookupToFunctionDetails(responseBody[handle] || responseBody));\n      }\n    }.bind(this);\n\n    if (this._consoleClient.isConsoleId(handle)) {\n      this._getFunctionDetailsOfConsoleId(handle, callback);\n    } else if (this._heapProfilerClient.isHeapObjectId(handle)) {\n      this._getFunctionDetailsOfHeapObjectId(handle, callback);\n    } else {\n      this._getFunctionDetailsOfObjectId(handle, callback);\n    }\n  },\n\n  _getFunctionDetailsOfObjectId: function(handle, callback) {\n    this._debuggerClient.request(\n      'lookup',\n      {\n        handles: [handle],\n        includeSource: false\n      },\n      callback\n    );\n  },\n\n  _getFunctionDetailsOfConsoleId: function(handle, callback) {\n    this._consoleClient.lookupConsoleId(handle, callback);\n  },\n\n  _getFunctionDetailsOfHeapObjectId: function(handle, callback) {\n    this._heapProfilerClient.lookupHeapObjectId(handle, callback);\n  },\n\n  restartFrame: function(params, done) {\n    this._debuggerClient.request(\n      'restartframe',\n      {\n        frame: Number(params.callFrameId)\n      },\n      this._handleChangeLiveOrRestartFrameResponse.bind(this, done)\n    );\n  },\n\n  setVariableValue: function(params, done) {\n    var version = this._debuggerClient.target.nodeVersion;\n    if (!DebuggerAgent.nodeVersionHasSetVariableValue(version)) {\n      done(\n        'V8 engine in node version ' + version +\n        ' does not support setting variable value from debugger.\\n' +\n        ' Please upgrade to version v0.10.12 (stable) or v0.11.2 (unstable)' +\n        ' or newer.');\n    } else {\n      this._doSetVariableValue(params, done);\n    }\n  },\n\n  _doSetVariableValue: function(params, done) {\n    var value = convert.inspectorValueToV8Value(params.newValue);\n\n    this._debuggerClient.request(\n      'setVariableValue',\n      {\n        name: params.variableName,\n        scope: {\n          number: Number(params.scopeNumber),\n          frameNumber: Number(params.callFrameId)\n        },\n        newValue: value\n      },\n      function(err, result) {\n        done(err, result);\n      }\n    );\n  },\n\n  setSkipAllPauses: function(params, done) {\n    if (params.skipped)\n      done(new Error('Not implemented.'));\n    else\n      done();\n  }\n};\n\nDebuggerAgent.nodeVersionHasSetVariableValue = function(version) {\n  return semver.satisfies(version, '~0.10.12 || ~0.11.2 || >=0.12');\n};\n\nexports.DebuggerAgent = DebuggerAgent;\n","/home/travis/build/npmtest/node-npmtest-node-inspector/node_modules/node-inspector/lib/ScriptFileStorage.js":"var fs = require('fs');\nvar path = require('path');\nvar async = require('async');\nvar debug = require('debug')('node-inspector:ScriptFileStorage');\n\nvar MODULE_HEADER = '(function (exports, require, module, __filename, __dirname) { ';\nvar MODULE_TRAILER = '\\n});';\nvar MODULE_WRAP_REGEX = new RegExp(\n  '^' + escapeRegex(MODULE_HEADER) +\n    '([\\\\s\\\\S]*)' +\n    escapeRegex(MODULE_TRAILER) + '$'\n);\n\nvar CONVENTIONAL_DIRS_PATTERN = [\n  /^[^\\/]*\\.js$/,\n  /^lib\\/[\\s\\S]*\\.js$/,\n  /^test\\/[\\s\\S]*\\.js$/,\n  /^node_modules\\/[\\s\\S]*\\.js$/\n];\nvar ALL_JS_PATTERN = [\n  /^[\\s\\S]*\\.js$/\n];\n\nfunction escapeRegex(str) {\n  return str.replace(/([/\\\\.?*()^${}|[\\]])/g, '\\\\$1');\n}\n\n/**\n * @param {{preload}} config\n * @param {ScriptManager} scriptManager\n * @constructor\n */\nfunction ScriptFileStorage(config, session) {\n  config = config || {};\n  this._hidden = config.hidden;\n  this._scriptManager = session.scriptManager;\n  this._noPreload = config.preload === false;\n}\n\nvar $class = ScriptFileStorage.prototype;\n\n$class.save = function(path, content, callback) {\n  var match = MODULE_WRAP_REGEX.exec(content);\n  if (!match) {\n    callback(new Error('The new content is not a valid node.js script.'));\n    return;\n  }\n  var newSource = match[1];\n  async.waterfall([\n    fs.readFile.bind(fs, path, 'utf-8'),\n\n    function(oldContent, cb) {\n      var match = /^(\\#\\!.*)/.exec(oldContent);\n      if (match)\n        newSource = match[1] + newSource;\n\n      fs.writeFile(path, newSource, cb);\n    }\n  ],\n  callback);\n};\n\n/**\n * @param {string} path\n * @param {function(Object, string)} callback\n */\n$class.load = function(path, callback) {\n  var scriptId = this._scriptManager.findScriptIdByPath(path);\n  // If requested source was loaded in app (scriptId != null), we can't expect that it is equal\n  // to the file with requested name stored in fs.\n  // So, if requested source was loaded in app, we need to require it from app.\n  if (scriptId != null) {\n    this._scriptManager.getScriptSourceById(scriptId, callback);\n  } else {\n    fs.readFile(\n      path,\n      'utf-8',\n      function(err, content) {\n        if (err) return callback(err);\n\n        // remove shebang\n        content = content.replace(/^\\#\\!.*/, '');\n\n        var source = MODULE_HEADER + content + MODULE_TRAILER;\n        return callback(null, source);\n      }\n    );\n  }\n};\n\n/**\n * @param {string} mainScriptFile\n * @param {function(Object, string)} callback\n * @this {ScriptFileStorage}\n */\n$class.findApplicationRoot = function(mainScriptFile, callback) {\n  fs.realpath(mainScriptFile, function(err, realPath) {\n    if (err) {\n      console.log('Cannot resolve real path of %s: %s', mainScriptFile, err);\n      realPath = mainScriptFile;\n    }\n    this._findApplicationRootForRealFile(realPath, callback);\n  }.bind(this));\n};\n\n/**\n * For a given script file, find the root directory containing all application\n * source files.\n *\n * Example:\n *   file = ~/work/app/bin/cli.js\n *   root = ~/work/app\n *\n * The algorithm:\n *\n * By default, we assume that the source file is in the root directory\n * (~/work/app/bin in the example above).\n *\n * If this directory does not contain 'package.json' and the parent directory\n * contains 'package.json', then we assume the parent directory is\n * the application root (~/work/app in the example above).\n *\n * @param {string} file\n * @param {function(Object, string)} callback\n * @this {ScriptFileStorage}\n */\n$class._findApplicationRootForRealFile = function(file, callback) {\n  var mainDir = path.dirname(file);\n  var parentDir = path.dirname(mainDir);\n\n  async.detect(\n    [mainDir, parentDir],\n    this._isApplicationRoot.bind(this),\n    function(result) {\n      callback(null, result || mainDir, !!result);\n    }\n  );\n};\n\n/**\n * @param {string} folder\n * @param {function(boolean)} callback\n */\n$class._isApplicationRoot = function(folder, callback) {\n  fs.exists(path.join(folder, 'package.json'), callback);\n};\n\n/**\n * @param {string} rootFolder\n * @param {string} include\n * @param {function(Object, Array.<string>?)} callback\n */\n$class.listScripts = function(rootFolder, include, callback) {\n  // This simpler solution unfortunately does not work on windows\n  // see https://github.com/isaacs/node-glob/pull/68\n  // glob(\n  //   '**/*.js',\n  //   { root: rootFolder },\n  //    callback\n  // );\n\n  debug('glob %s on %s', include, rootFolder);\n\n  var exclude = this._hidden;\n  list(rootFolder, include, exclude, function(error, result) {\n    if (result) {\n      result = result.map(function(unixPath) {\n        return unixPath.split('/').join(path.sep);\n      });\n    }\n\n    debug('glob returned %s files', error || result.length);\n    callback(error, result);\n  });\n};\n\n$class._findScriptsOfRunningApp = function(mainScriptFile, callback) {\n  if (!mainScriptFile) {\n    // mainScriptFile is null when running in the REPL mode\n    return process.nextTick(callback.bind(null, null, []));\n  }\n\n  async.waterfall(\n    [\n      this.findApplicationRoot.bind(this, mainScriptFile),\n      function(dir, isRoot, cb) {\n        var include = isRoot ? ALL_JS_PATTERN : CONVENTIONAL_DIRS_PATTERN;\n        this.listScripts(dir, include, cb);\n      }.bind(this)\n    ],\n    callback\n  );\n};\n\n$class._findScriptsOfStartDirectoryApp = function(startDirectory, callback) {\n  this._isApplicationRoot(\n    startDirectory,\n    function handleIsStartDirectoryApplicationRoot(result) {\n      if (!result) {\n        callback(null, []);\n      } else {\n        this.listScripts(startDirectory, ALL_JS_PATTERN, callback);\n      }\n    }.bind(this)\n  );\n};\n\n/**\n * @param {string} startDirectory\n * @param {string} mainScriptFile\n * @param {function(Object, Array.<string>)} callback\n * @this {ScriptFileStorage}\n */\n$class.findAllApplicationScripts = function(startDirectory, mainScriptFile, callback) {\n  if (this._noPreload) {\n    return process.nextTick(function() { callback(null, []); });\n  }\n  async.series(\n    [\n      this._findScriptsOfRunningApp.bind(this, mainScriptFile),\n      this._findScriptsOfStartDirectoryApp.bind(this, startDirectory)\n    ],\n    function(err, results) {\n      if (err) return callback(err);\n\n      var files = results[0].concat(results[1]);\n\n      debug('findAllApplicationScripts returned %s files', files.length);\n      return callback(null, files);\n    }.bind(this)\n  );\n};\n\nvar list = function(root, include, exclude, cb) {\n  include = include || [];\n  exclude = exclude || [];\n\n  var folders = [root];\n  var cache = {};\n  var list = [];\n  var node = null;\n  var realpaths = {};\n\n  iterator();\n\n  function iterator(error) {\n    if (error) console.warn('Access to ' + node + ' from ResourceTree denied. (' + error + ')');\n    if (folders.length) return iterate(node = folders.pop());\n    return cb(null, list);\n  }\n\n  function iterate(node) {\n    async.waterfall([\n      fs.readdir.bind(fs, node),\n      function(paths, cb) {\n        async.each(paths, function(child, cb) {\n          var apath = path.join(node, child);\n          var rpath = relative(apath);\n\n          fs.realpath(apath, realpaths, function(err, realpath) {\n            if (err) { return cb(err); }\n            if (cache[realpath] || excluded(rpath)) return cb();\n            cache[realpath] = true;\n\n            fs.stat(realpath, function(error, pstat) {\n              if (error) return cb(error);\n\n              if (pstat.isDirectory()) folders.push(realpath);\n              if (pstat.isFile() && included(rpath)) list.push(realpath);\n              cb();\n            });\n          });\n        }, cb);\n      }\n    ], iterator);\n  }\n\n  function included(rpath) {\n    return include.some(function(rx) { return rx.test(rpath); });\n  }\n\n  function excluded(rpath) {\n    return exclude.some(function(rx) { return rx.test(rpath); });\n  }\n\n  function relative(apath) {\n    return path.relative(root, apath);\n  }\n};\n\nexports.ScriptFileStorage = ScriptFileStorage;\n","/home/travis/build/npmtest/node-npmtest-node-inspector/node_modules/node-inspector/lib/DebuggerClient.js":"var extend = require('util')._extend;\nvar EventEmitter = require('events').EventEmitter,\n  inherits = require('util').inherits,\n  DebugConnection = require('./debugger.js');\n\nfunction createFailingConnection(reason) {\n  return {\n    connected: false,\n    isRunning: false,\n\n    request: function(command, args, callback) {\n      callback({ message: new ErrorNotConnected(reason) });\n    },\n\n    close: function() {\n    }\n  };\n}\n\n/**\n * @constructor\n * @param {number} debuggerPort\n */\nfunction DebuggerClient(debuggerHost, debuggerPort) {\n  this._conn = createFailingConnection('node-inspector server was restarted');\n  this._host = debuggerHost;\n  this._port = debuggerPort;\n\n  this.target = null;\n}\n\ninherits(DebuggerClient, EventEmitter);\n\nObject.defineProperties(DebuggerClient.prototype, {\n  /** @type {boolean} */\n  isRunning: {\n    get: function() {\n      return this._conn.isRunning;\n    }\n  },\n\n  isConnected: {\n    get: function() {\n      return this._conn.connected;\n    }\n  },\n\n  isReady: {\n    get: function() {\n      return this._conn.connected && !!this.target;\n    }\n  }\n});\n\nDebuggerClient.prototype.connect = function() {\n  this._conn = DebugConnection.attachDebugger(this._host, this._port);\n  this.pendingEvents = [];\n  this._conn\n    .on('connect', this._onConnectionOpen.bind(this))\n    .on('error', this.emit.bind(this, 'error'))\n    .on('close', this._onConnectionClose.bind(this))\n    .on('event', function(obj) {\n      if (this.isReady) {\n        this.emit(obj.event, obj.body);\n      } else {\n        this.pendingEvents.push(obj);\n      }\n     }.bind(this));\n};\n\nDebuggerClient.prototype._onConnectionOpen = function() {\n  // We need to update isRunning flag before we continue with debugging.\n  // Send a dummy request so that we can read the state from the response.\n  // We also need to get node version of the debugged process,\n  // therefore the dummy request is `evaluate 'process.version'`\n\n  var describeProgram = '(' + function() {\n    return {\n      break: process.execArgv.some(function(argv){\n        // we may get --debug-brk or --debug-brk=port\n        return argv.indexOf('--debug-brk') === 0;\n      }),\n      pid: console.log('') && process.pid,\n      cwd: process.cwd(),\n      filename: process.mainModule ? process.mainModule.filename : process.argv[1],\n      nodeVersion: process.version\n    };\n  } + ')()';\n\n  this.evaluateGlobal(describeProgram, function(error, result) {\n    this.target = result;\n    this.emit('connect');\n    this.pendingEvents.forEach(function(obj) {\n      this.emit(obj.event, obj.body);\n    }.bind(this));\n    this.pendingEvents = [];\n  }.bind(this));\n};\n\n/**\n * @param {string} reason\n */\nDebuggerClient.prototype._onConnectionClose = function(reason) {\n  this._conn = createFailingConnection(reason);\n  this.target = null;\n  this.emit('close', reason);\n};\n\n/**\n * @param {string} command\n * @param {!Object} args\n * @param {function(error, response, refs)} callback\n */\nDebuggerClient.prototype.request = function(command, args, callback) {\n  if (typeof callback !== 'function') {\n    callback = function(error) {\n      if (!error) return;\n      console.log('Warning: ignored V8 debugger error. %s', error);\n    };\n  }\n\n  // Note: we must not add args object if it was not sent.\n  // E.g. resume (V8 request 'continue') does no work\n  // correctly when args are empty instead of undefined\n  if (args && args.maxStringLength == null && command !== 'continue')\n    args.maxStringLength = -1;\n\n  this._conn.request(command, { arguments: args }, function(response) {\n    var refsLookup;\n    if (!response.success)\n      callback(response.message);\n    else {\n      refsLookup = {};\n      if (response.refs)\n        response.refs.forEach(function(r) { refsLookup[r.handle] = r; });\n      callback(null, response.body, refsLookup);\n    }\n  });\n};\n\n/**\n */\nDebuggerClient.prototype.close = function() {\n  if (this.isConnected)\n    this._conn.close();\n  else\n    this.emit('close');\n};\n\n/**\n * @param {number} breakpointId\n * @param {function(error, response, refs)} done\n */\nDebuggerClient.prototype.clearBreakpoint = function(breakpointId, done) {\n  this.request(\n    'clearbreakpoint',\n    {\n      breakpoint: breakpointId\n    },\n    done\n  );\n};\n\n/**\n * @param {string} expression\n * @param {function(error, response)} done\n */\nDebuggerClient.prototype.evaluateGlobal = function(expression, done) {\n  this.request(\n    'evaluate',\n    {\n      expression: 'JSON.stringify(' + expression + ')',\n      global: true\n    },\n    function _handleEvaluateResponse(err, result) {\n      done(err, JSON.parse(result.value));\n    }\n  );\n};\n\n/**\n * @param {string} message\n * @constructor\n */\nfunction ErrorNotConnected(message) {\n  Error.call(this);\n  this.name = ErrorNotConnected.name;\n  this.message = message;\n}\n\ninherits(ErrorNotConnected, Error);\n\nexports.DebuggerClient = DebuggerClient;\nexports.ErrorNotConnected = ErrorNotConnected;\n","/home/travis/build/npmtest/node-npmtest-node-inspector/node_modules/node-inspector/lib/debugger.js":"var Net = require('net'),\n    Protocol = require('_debugger').Protocol,\n    inherits = require('util').inherits,\n    EventEmitter = require('events').EventEmitter,\n    debugProtocol = require('debug')('node-inspector:protocol:v8-debug'),\n    callbackHandler = require('./callback').create();\n\n/**\n* @param {Number} port\n*/\nfunction Debugger(host, port){\n  this._host = host;\n  this._port = port;\n  this._connected = false;\n  this._connection = null;\n  this._lastError = null;\n  this._ignoreErrors = false;\n\n  this._setupConnection();\n}\n\ninherits(Debugger, EventEmitter);\n\nObject.defineProperties(Debugger.prototype, {\n  /** @type {boolean} */\n  isRunning: { writable: true, value: true },\n\n  /** @type {boolean} */\n  connected: {\n    get: function() {\n      return this._connected;\n    }\n  }\n});\n\nDebugger.prototype._setupConnection = function() {\n  var connection = Net.createConnection(this._port, this._host),\n      protocol = new Protocol();\n\n  protocol.onResponse = this._processResponse.bind(this);\n\n  connection\n    .on('connect', this._onConnectionOpen.bind(this))\n    .on('data', protocol.execute.bind(protocol))\n    .on('error', this._onConnectionError.bind(this))\n    .on('end', this.close.bind(this))\n    .on('close', this._onConnectionClose.bind(this))\n    .setEncoding('utf8');\n\n  this._connection = connection;\n};\n\nDebugger.prototype._onConnectionOpen = function() {\n  this._connected = true;\n  this.emit('connect');\n};\n\n\n/**\n* @param {Error} err\n*/\nDebugger.prototype._onConnectionError = function(err) {\n  if (this._ignoreErrors) return;\n\n  if (err.code == 'ECONNREFUSED') {\n    err.helpString = 'Is node running with --debug port ' + this._port + '?';\n  } else if (err.code == 'ECONNRESET') {\n    err.helpString = 'Check there is no other debugger client attached to port ' + this._port + '.';\n  }\n\n  this._lastError = err.toString();\n  if (err.helpString) {\n    this._lastError += '. ' + err.helpString;\n  }\n\n  this.emit('error', err);\n};\n\nDebugger.prototype._onConnectionClose = function(hadError) {\n  this.emit('close', hadError ? this._lastError : 'Debugged process exited.');\n\n  this._port = null;\n  this._connected = false;\n  this._connection = null;\n  this._lastError = null;\n};\n\nDebugger.prototype._processResponse = function(message) {\n  var obj = message.body;\n\n  if (typeof obj.running === 'boolean') {\n    this.isRunning = obj.running;\n  }\n  if (obj.type === 'response' && obj.request_seq > 0) {\n    debugProtocol('response: ' + JSON.stringify(message.body));\n    callbackHandler.processResponse(obj.request_seq, [obj]);\n  }\n  else if (obj.type === 'event') {\n    debugProtocol('event: ' + JSON.stringify(message.body));\n    if (['break', 'exception'].indexOf(obj.event) > -1) {\n      this.isRunning = false;\n    }\n    this.emit('event', obj);\n  }\n  else {\n    debugProtocol('unknown: ' + JSON.stringify(message.body));\n  }\n};\n\n/**\n* @param {string} data\n*/\nDebugger.prototype.send = function(data) {\n  debugProtocol('request: ' + data);\n  if (this.connected) {\n    this._connection.write('Content-Length: ' + Buffer.byteLength(data, 'utf8') + '\\r\\n\\r\\n' + data);\n  }\n};\n\n\n/**\n* @param {string} command\n* @param {Object} params\n* @param {function} callback\n*/\nDebugger.prototype.request = function(command, params, callback) {\n  var message = {\n    seq: 0,\n    type: 'request',\n    command: command\n  };\n  if (typeof callback === 'function') {\n    message.seq = callbackHandler.wrap(callback);\n  }\n  if (params) {\n    Object.keys(params).forEach(function(key) {\n      message[key] = params[key];\n    });\n  }\n  this.send(JSON.stringify(message));\n};\n\n/**\n*/\nDebugger.prototype.close = function() {\n  this._ignoreErrors = true;\n  this.request('disconnect');\n  this._connection.end();\n};\n\n/**\n* @param {Number} port\n* @type {Debugger}\n*/\nmodule.exports.attachDebugger = function(host, port) {\n  return new Debugger(host, port);\n};\n","/home/travis/build/npmtest/node-npmtest-node-inspector/node_modules/node-inspector/lib/callback.js":"\n/**\n * Create a callback container\n * @return {Object} that wraps callbacks and returns a one-time id.\n */\nexports.create = function() {\n  var lastId = 1,\n      callbacks = {};\n\n  return Object.create({}, {\n    wrap: {\n      value: function(callback) {\n        var callbackId = lastId++;\n        callbacks[callbackId] = callback || function() {};\n        return callbackId;\n      }\n    },\n    processResponse: {\n      value: function(callbackId, args) {\n        var callback = callbacks[callbackId];\n\n        if (callback) {\n          callback.apply(null, args);\n        }\n\n        delete callbacks[callbackId];\n      }\n    },\n    removeResponseCallbackEntry: {\n      value: function(callbackId) {\n        delete callbacks[callbackId];\n      }\n    }\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-node-inspector/node_modules/node-inspector/lib/FrontendClient.js":"var EventEmitter = require('events').EventEmitter,\n    inherits = require('util').inherits,\n    debugProtocol = require('debug')('node-inspector:protocol:devtools'),\n    ErrorNotConnected = require('./DebuggerClient').ErrorNotConnected;\n\n/**\n * FrontendClient encapsulates communication with front-end running in browser.\n * @param {{on: Function, send: Function}} connection\n *   Socket.io connection object.\n * @constructor\n * @extends EventEmitter\n */\nfunction FrontendClient(connection) {\n  this._connection = connection;\n  this._registerEventHandlers();\n}\n\ninherits(FrontendClient, EventEmitter);\n\nObject.defineProperties(FrontendClient.prototype, {\n  /** @type {boolean} */\n  isConnected: {\n    get: function() {\n      return this._connection != null;\n    }\n  }\n});\n\nFrontendClient.prototype._registerEventHandlers = function() {\n  this._connection.on('close', this._onConnectionClose.bind(this));\n  this._connection.on('message', this._onConnectionMessage.bind(this));\n};\n\nFrontendClient.prototype._onConnectionClose = function() {\n  this._connection = null;\n  this.emit('close');\n};\n\nFrontendClient.prototype._onConnectionMessage = function(message) {\n  this.emit('message', message);\n};\n\n/**\n * Send a message to front-end.\n * @param {!Object|string} message\n */\nFrontendClient.prototype._sendMessage = function(message) {\n  var payload = typeof message == 'string' ? message : JSON.stringify(message);\n  debugProtocol('backend: ' + payload);\n\n  if (!this._connection) {\n    if (!this._errorMessageDisplayed) {\n      console.log('Cannot send response - there is no front-end connection.');\n      this._errorMessageDisplayed = true;\n    }\n\n    return;\n  }\n\n  this._errorMessageDisplayed = false;\n\n  this._connection.send(payload);\n};\n\n/**\n * Send a response to a front-end request.\n * @param {number} requestId Id of the request.\n * @param {string} fullMethodName\n * @param {?string} error Error message or null/undefined on success.\n * @param {Object=} result Response data on success.\n */\nFrontendClient.prototype.sendResponse = function(requestId,\n                                                 fullMethodName,\n                                                 error,\n                                                 result) {\n  if (requestId == null) {\n    throw new Error(\n      'Cannot send response to ' +\n        fullMethodName +\n        ' without a requestId');\n  }\n\n  var message = { id: requestId };\n  if (error != null) {\n    this._onErrorResponse(fullMethodName, error);\n    message.error = error.toString();\n  } else {\n    message.result = result;\n  }\n\n  this._sendMessage(message);\n};\n\nFrontendClient.prototype._onErrorResponse = function(fullMethodName, error) {\n  if (error instanceof ErrorNotConnected) {\n    this.sendInspectorDetached(error.message);\n  }\n  this.sendLogToConsole('error', fullMethodName + ' failed.\\n' + error);\n};\n\n/**\n * Send an event to the front-end.\n * @param {string} eventName Event name in form 'Agent.method'.\n * @param {Object=} data Event data (method arguments).\n */\nFrontendClient.prototype.sendEvent = function(eventName, data) {\n  var message = {\n    method: eventName,\n    params: data || {}\n  };\n  if (this._eventsPaused) {\n    this._eventsBuffer.push(message);\n  } else {\n    this._sendMessage(message);\n  }\n};\n\nFrontendClient.prototype.pauseEvents = function() {\n  if (this._eventsPaused) return;\n  this._eventsPaused = true;\n  this._eventsBuffer = [];\n};\n\nFrontendClient.prototype.resumeEvents = function() {\n  if (!this._eventsPaused) return;\n\n  // We are making a copy of the buffered messages list,\n  // so that the messages are sent event when pauseEvents()\n  // is called before the next tick.\n  var messages = this._eventsBuffer;\n  process.nextTick(function() {\n    messages.forEach(this._sendMessage, this);\n  }.bind(this));\n\n  this._eventsPaused = false;\n  this._eventsBuffer = null;\n};\n\n/**\n * Ask frontend to add a new log into console window.\n * @param {string} level Message level (error, warning, log, debug).\n * @param {string} text\n */\nFrontendClient.prototype.sendLogToConsole = function(level, text) {\n  this.sendEvent('Console.showConsole');\n  this.sendEvent(\n    'Console.messageAdded',\n    {\n      message: {\n        source: 3,\n        type: 0,\n        level: level,\n        line: 0,\n        column: 0,\n        url: '',\n        groupLevel: 7,\n        repeatCount: 1,\n        text: text\n      }\n    }\n  );\n};\n\n/**\n * Shortcut for sendEvent('Inspector.detached', reason)\n * @param {string} reason\n */\nFrontendClient.prototype.sendInspectorDetached = function(reason) {\n  this.sendEvent('Inspector.detached', { reason: reason });\n};\n\nexports.FrontendClient = FrontendClient;\n","/home/travis/build/npmtest/node-npmtest-node-inspector/node_modules/node-inspector/lib/FrontendCommandHandler.js":"var debugProtocol = require('debug')('node-inspector:protocol:devtools');\n\nvar RuntimeAgent = require('./RuntimeAgent').RuntimeAgent,\n  PageAgent = require('./PageAgent').PageAgent,\n  NetworkAgent = require('./NetworkAgent').NetworkAgent,\n  DebuggerAgent = require('./DebuggerAgent').DebuggerAgent,\n  ProfilerAgent = require('./ProfilerAgent').ProfilerAgent,\n  HeapProfilerAgent = require('./HeapProfilerAgent').HeapProfilerAgent,\n  ConsoleAgent = require('./ConsoleAgent').ConsoleAgent;\n\n/**\n * @param {Object} config\n * @param {FrontendClient} frontendClient\n * @param {DebuggerClient} debuggerClient\n * @param {BreakEventHandler} breakEventHandler\n * @param {ScriptManager} scriptManager\n * @param {InjectorClient} injectorClient\n * @param {ConsoleClient} consoleClient\n * @param {HeapProfilerClient} heapProfilerClient\n */\nfunction FrontendCommandHandler(config, session) {\n  this._config = config;\n  this._session = session;\n  this._agents = {};\n  this._specialCommands = {};\n  this._frontendClient = session.frontendClient;\n  this._debuggerClient = session.debuggerClient;\n  this._breakEventHandler = session.breakEventHandler;\n  this._scriptManager = session.scriptManager;\n  this._consoleClient = session.consoleClient;\n  this._heapProfilerClient = session.heapProfilerClient;\n  this._injectorClient = session.injectorClient;\n  this._initializeRegistry();\n  this._registerEventHandlers();\n  this._pauseInitialEvents();\n}\n\nFrontendCommandHandler.prototype = {\n  _initializeRegistry: function() {\n    this._registerAgent('Debugger', new DebuggerAgent(this._config, this._session));\n    this._registerAgent('Console', new ConsoleAgent(this._config, this._session));\n    this._registerAgent('Runtime', new RuntimeAgent(this._config, this._session));\n    this._registerAgent('Page', new PageAgent(this._config, this._session));\n    this._registerAgent('Network', new NetworkAgent(this._config, this._session));\n    this._registerAgent('Profiler',new ProfilerAgent(this._config, this._session));\n    this._registerAgent('HeapProfiler', new HeapProfilerAgent(this._config, this._session));\n\n    //TODO(3y3):\n    //  Remove next from noop before closing #341:\n    //  - DOMDebugger.setXHRBreakpoint\n    //  - DOMDebugger.removeXHRBreakpoint\n    this._registerNoopCommands(\n      'Network.enable',\n      'Network.setCacheDisabled',\n      'Console.enable',\n      'Console.setMonitoringXHREnabled',\n      'Console.addInspectedHeapObject',\n      'Database.enable',\n      'DOMDebugger.setXHRBreakpoint',\n      'DOMDebugger.removeXHRBreakpoint',\n      'DOMDebugger.setInstrumentationBreakpoint',\n      'DOMDebugger.removeInstrumentationBreakpoint',\n      'DOMStorage.enable',\n      'DOM.hideHighlight',\n      'Inspector.enable',\n      'Page.addScriptToEvaluateOnLoad',\n      'Page.removeScriptToEvaluateOnLoad',\n      'Page.setDeviceOrientationOverride',\n      'Page.clearDeviceOrientationOverride',\n      'Page.setGeolocationOverride',\n      'Page.clearGeolocationOverride',\n      'Page.setContinuousPaintingEnabled',\n      'Page.setEmulatedMedia',\n      'Page.setDeviceMetricsOverride',\n      'Page.setScriptExecutionDisabled',\n      'Page.setShowDebugBorders',\n      'Page.setShowFPSCounter',\n      'Page.setShowScrollBottleneckRects',\n      'Page.setShowViewportSizeOnResize',\n      'Page.setShowPaintRects',\n      'Page.setForceCompositingMode',\n      'CSS.enable',\n      'CSS.disable',\n      'DOM.enable',\n      'DOM.disable',\n\n      'Runtime.run',\n      'IndexedDB.enable',\n      'HeapProfiler.enable',\n      'Debugger.setAsyncCallStackDepth',\n      'Debugger.skipStackFrames',\n      'Console.setTracingBasedTimeline',\n      'Profiler.setSamplingInterval',\n      'Worker.setAutoconnectToWorkers'\n    );\n\n    this._registerQuery('CSS.getSupportedCSSProperties', { cssProperties: []});\n    this._registerQuery('Worker.canInspectWorkers', { result: false });\n    this._registerQuery('Page.getScriptExecutionStatus', { result: 'enabled' });\n    this._registerQuery('IndexedDB.requestDatabaseNames', { databaseNames: [] });\n  },\n\n  _registerAgent: function(name, agent) {\n    this._agents[name] = agent;\n  },\n\n  _registerNoopCommands: function() {\n    var i, fullMethodName;\n    for (i = 0; i < arguments.length; i++) {\n      fullMethodName = arguments[i];\n      this._specialCommands[fullMethodName] = {};\n    }\n  },\n\n  _registerQuery: function(fullMethodName, result) {\n    this._specialCommands[fullMethodName] = { result: result };\n  },\n\n  _registerEventHandlers: function() {\n    this._frontendClient.on(\n      'message',\n       this._handleFrontendMessage.bind(this));\n  },\n\n  _handleFrontendMessage: function(message) {\n    debugProtocol('frontend: ' + message);\n    var command = JSON.parse(message);\n    this.handleCommand(command);\n  },\n\n  _pauseInitialEvents: function() {\n    this._frontendClient.pauseEvents();\n    this._session.once('resource-tree-resolved', function() {\n      this._frontendClient.resumeEvents();\n    }.bind(this));\n  },\n\n  handleCommand: function(messageObject) {\n    var fullMethodName = messageObject.method,\n      domainAndMethod = fullMethodName.split('.'),\n      domainName = domainAndMethod[0],\n      methodName = domainAndMethod[1],\n      requestId = messageObject.id,\n      agent,\n      method;\n\n    if (this._specialCommands[fullMethodName]) {\n      this._handleMethodResult(\n        requestId,\n        fullMethodName,\n        null,\n        this._specialCommands[fullMethodName].result);\n      return;\n    }\n\n    agent = this._agents[domainName];\n    if (!agent) {\n      this._sendNotImplementedResponse(requestId, fullMethodName);\n      return;\n    }\n\n    method = agent[methodName];\n    if (!method || typeof method !== 'function') {\n      this._sendNotImplementedResponse(requestId, fullMethodName);\n      return;\n    }\n\n\n    method.call(agent, messageObject.params, function(error, result) {\n      this._handleMethodResult(messageObject.id, fullMethodName, error, result);\n    }.bind(this));\n  },\n\n  _sendNotImplementedResponse: function(requestId, fullMethodName) {\n    console.log(\n      'Received request for a method not implemented:',\n      fullMethodName\n    );\n\n    this._handleMethodResult(\n      requestId,\n      fullMethodName,\n      new Error('Not implemented.')\n    );\n  },\n\n  _handleMethodResult: function(requestId, fullMethodName, error, result) {\n    var response;\n\n    if (!requestId) {\n      if (response !== undefined)\n        console.log('Warning: discarded result of ' + fullMethodName);\n      return;\n    }\n\n    this._frontendClient.sendResponse(requestId, fullMethodName, error, result);\n  }\n};\n\nexports.FrontendCommandHandler = FrontendCommandHandler;\n","/home/travis/build/npmtest/node-npmtest-node-inspector/node_modules/node-inspector/lib/RuntimeAgent.js":"// node-inspector version of on webkit-inspector/InspectorRuntimeAgent.cpp\nvar convert = require('./convert.js'),\n    util = require('util'),\n    CallFramesProvider = require('./CallFramesProvider.js').CallFramesProvider;\n\n/**\n * @param {Object} config\n * @param {DebuggerClient} debuggerClient\n * @param {FrontendClient} frontendClient\n * @param {ConsoleClient} consoleClient\n * @param {HeapProfilerClient} heapProfilerClient\n * @constructor\n */\nfunction RuntimeAgent(config, session) {\n  this._debuggerClient = session.debuggerClient;\n  this._frontendClient = session.frontendClient;\n  this._consoleClient = session.consoleClient;\n  this._heapProfilerClient = session.heapProfilerClient;\n  this._callFramesProvider = new CallFramesProvider(config, session);\n}\n\nRuntimeAgent.prototype = {\n  enable: function(params, done) {\n    done();\n    //Relative to WorkerRuntimeAgent::enable in core/inspector/WorkerRuntimeAgent.cpp\n    this._frontendClient.sendEvent('Runtime.executionContextCreated', {\n      context: {\n        id: 1,\n        isPageContext: true,\n        name: ''\n      }\n    });\n  },\n\n  evaluate: function(params, done) {\n    var self = this;\n\n    self._debuggerClient.request(\n      'evaluate',\n      {\n        expression: params.expression,\n        global: true\n      },\n      function(err, result) {\n        // Errors from V8 are actually just messages, so we need to fill them out a bit.\n        if (err) {\n          err = convert.v8ErrorToInspectorError(err);\n        }\n\n        done(null, {\n          result: err || convert.v8ResultToInspectorResult(result),\n          wasThrown: !!err\n        });\n      }\n    );\n  },\n\n  callFunctionOn: function(params, done) {\n    function callFunctionWithParams(err, evaluateParams) {\n      if (err) {\n        done(err);\n        return;\n      }\n\n      var callback = this._handleCallFunctionOnObjectResponse\n        .bind(this, done, params.returnByValue);\n\n      this._debuggerClient.request(\n        'evaluate',\n        evaluateParams,\n        callback\n      );\n    }\n\n    this._createEvaluateParamsForFunctionCall(\n      params.objectId,\n      params.functionDeclaration,\n      params.arguments,\n      callFunctionWithParams.bind(this)\n    );\n  },\n\n  _createEvaluateParamsForFunctionCall:\n    function(selfId, declaration, args, done) {\n      args = args || [];\n\n      try {\n        var argsData = args.map(this._getFunctionCallArgsData.bind(this));\n        var params = this._buildEvaluateParamsFromArgsData(\n          selfId,\n          declaration,\n          argsData);\n        done(null, params);\n      } catch (err) {\n        done(err);\n      }\n    },\n\n  _buildEvaluateParamsFromArgsData: function(selfId, declaration, argsData) {\n    argsData.unshift(this._getSelfArgData(selfId));\n\n    var argNames = argsData.map(function(a) { return a.code; });\n    var argContexts = argsData\n      .map(function(a) { return a.context; })\n      // filter out empty contexts (value types are context-less)\n      .filter(function(c) { return !!c; });\n\n    var expression = util.format(\n      '(%s).call(%s)',\n      declaration,\n      argNames.join(', '));\n\n    return {\n      expression: expression,\n      global: true,\n      additional_context: argContexts\n    };\n  },\n\n  _getSelfArgData: function(selfId) {\n    var SELF_CONTEXT_NAME = '__node_inspector_self__';\n    return {\n      code: SELF_CONTEXT_NAME,\n      context: {\n        name: SELF_CONTEXT_NAME,\n        handle: Number(selfId)\n      }\n    };\n  },\n\n  _getFunctionCallArgsData: function(arg, index) {\n    var uniqueId = '__node_inspector_arg' + index;\n    switch (arg.type) {\n      case undefined:\n      case 'string':\n        return { code: util.format('\"%s\"', arg.value) };\n      case 'number':\n        return { code: arg.value };\n      case 'null':\n      case 'undefined':\n        return { code: arg.type };\n      case 'object':\n      case 'function':\n        return {\n          code: uniqueId,\n          context: {\n            name: uniqueId,\n            handle: Number(arg.objectId)\n          }\n        };\n      default:\n        throw new Error(util.format(\n          'Function arguments of type \"%s\" are not supported',\n          arg.type\n        ));\n    }\n  },\n\n  _handleCallFunctionOnObjectResponse:\n    function(done, returnByValue, err, response) {\n      if (err) {\n        done(null, {\n          err: err,\n          wasThrown: true\n        });\n        return;\n      }\n\n      var value = {};\n      if (returnByValue && response.properties) {\n        for (var i = 0; i < response.properties.length; i++) {\n          value[response.properties[i].name] = true;\n        }\n      }\n\n      done(null, {\n        result: { value: value },\n        wasThrown: false\n      });\n    },\n\n  getProperties: function(params, done) {\n    // TODO implement the new way of getting object properties\n    //\n    // Front-end sends the following two requests for Object properties:\n    // \"params\": {\"objectId\":\"78\",\"ownProperties\":false,\"accessorPropertiesOnly\":true}\n    // \"params\":{\"objectId\":\"78\",\"ownProperties\":true,\"accessorPropertiesOnly\":false}\n    //\n    // Or the following request for Scope properties:\n    // \"params\":{\"objectId\":\"scope:0:2\",\"ownProperties\":false,\"accessorPropertiesOnly\":false}\n    // See getProperties() and getInjectedProperties() in\n    //   http://src.chromium.org/blink/branches/chromium/1625/Source/core/\n    //    inspector/InjectedScriptSource.js\n    // for more details.\n    var options = {\n      ownProperties: params.ownProperties,\n      accessorPropertiesOnly: params.accessorPropertiesOnly\n    };\n    if (this._callFramesProvider.isScopeId(params.objectId)) {\n      this._getPropertiesOfScopeId(params.objectId, options, done);\n    } else if (this._consoleClient.isConsoleId(params.objectId)) {\n      this._getPropertiesOfConsoleId(params.objectId, options, done);\n    } else if (this._heapProfilerClient.isHeapObjectId(params.objectId)) {\n      this._getPropertiesOfHeapObjectId(params.objectId, options, done);\n    } else {\n      this._getPropertiesOfObjectId(params.objectId, options, done);\n    }\n  },\n\n  _getPropertiesOfScopeId: function(scopeId, options, done) {\n    this._callFramesProvider.resolveScopeId(\n      scopeId,\n      function(err, result) {\n        if (err) {\n          done(err);\n        } else {\n          this._getPropertiesOfObjectId(result, options, done);\n        }\n      }.bind(this)\n    );\n  },\n\n  _getPropertiesOfObjectId: function(objectId, options, done) {\n    var handle = parseInt(objectId, 10);\n    var request = { handles: [handle], includeSource: false };\n    this._debuggerClient.request(\n      'lookup',\n      request,\n      function(error, responseBody, responseRefs) {\n        if (error) {\n          done(error);\n          return;\n        }\n        var obj = responseBody[handle],\n            props = convert.v8ObjectToInspectorProperties(obj, responseRefs, options);\n\n        done(null, { result: props });\n      }\n    );\n  },\n\n  _getPropertiesOfConsoleId: function(objectId, options, done) {\n    this._consoleClient.lookupConsoleId(\n      objectId,\n      function(error, responseBody, responseRefs) {\n        if (error) return done(error);\n\n        var props = convert.v8ObjectToInspectorProperties(responseBody, responseRefs, options);\n\n        done(null, { result: props });\n      }.bind(this)\n    );\n  },\n\n  _getPropertiesOfHeapObjectId: function(objectId, options, done) {\n    this._heapProfilerClient.lookupHeapObjectId(\n      objectId,\n      function(error, responseBody, responseRefs) {\n        if (error) return done(error);\n\n        var props = convert.v8ObjectToInspectorProperties(responseBody, responseRefs, options);\n\n        done(null, { result: props });\n      }.bind(this)\n    );\n  },\n\n  releaseObjectGroup: function(params, done) {\n    // V8 debugger protocol does not support object groups\n    done();\n  },\n\n  releaseObject: function(params, done) {\n    // V8 debugger protocol does not support manual release\n    done();\n  }\n};\n\nexports.RuntimeAgent = RuntimeAgent;\n","/home/travis/build/npmtest/node-npmtest-node-inspector/node_modules/node-inspector/lib/PageAgent.js":"// node-inspector version of on webkit-inspector/InspectorPageAgent.cpp\nvar fs = require('fs'),\n  path = require('path'),\n  inherits = require('util').inherits,\n  extend = require('util')._extend,\n  EventEmitter = require('events').EventEmitter,\n  async = require('async'),\n  convert = require('./convert.js'),\n  ScriptFileStorage = require('./ScriptFileStorage.js').ScriptFileStorage;\n\n\n/**\n * @param {{preload}} config\n * @param {DebuggerClient} debuggerClient\n * @param {ScriptManager} scriptManager\n * @constructor\n */\nfunction PageAgent(config, session) {\n  this._session = session;\n  this._debuggerClient = session.debuggerClient;\n  this._scriptManager = session.scriptManager;\n  this._scriptStorage = new ScriptFileStorage(config, session);\n}\n\ninherits(PageAgent, EventEmitter);\n\nextend(PageAgent.prototype, {\n  enable: function(params, done) {\n    done();\n  },\n\n  canEmulate: function(params, done) {\n    done(null, { result: false });\n  },\n\n  canScreencast: function(params, done) {\n    done(null, { result: false });\n  },\n\n  setTouchEmulationEnabled: function(params, done) {\n    done();\n  },\n\n  getResourceTree: function(params, done) {\n    var cb = function() {\n      done.apply(null, arguments);\n      this._session.emit('resource-tree-resolved');\n    }.bind(this);\n\n    if (this._debuggerClient.isReady) {\n      this._doGetResourceTree(params, cb);\n    } else {\n      this._debuggerClient.once(\n        'connect',\n        this._doGetResourceTree.bind(this, params, cb)\n      );\n    }\n  },\n\n  _doGetResourceTree: function(params, done) {\n    var cwd = this._debuggerClient.target.cwd;\n    var filename = this._debuggerClient.target.filename;\n    if (!this._debuggerClient.isHostMachine) {\n        return done();\n    }\n    async.waterfall(\n      [\n        this._resolveMainAppScript.bind(this, cwd, filename),\n        this._getResourceTreeForAppScript.bind(this, this._debuggerClient.target)\n      ],\n      done\n    );\n  },\n\n  _resolveMainAppScript: function(startDirectory, mainAppScript, done) {\n    this._scriptManager.mainAppScript = mainAppScript;\n    if (mainAppScript == null) {\n      // mainScriptFile is null when running in the REPL mode\n      return done(null, startDirectory, mainAppScript);\n    }\n\n    fs.stat(mainAppScript, function(err, stat) {\n      if (err && !/\\.js$/.test(mainAppScript)) {\n        mainAppScript += '.js';\n      }\n\n      if (process.platform !== 'win32') {\n        this._scriptManager.realMainAppScript = mainAppScript;\n        return done(null, startDirectory, mainAppScript);\n      }\n\n      var dirname = path.dirname(mainAppScript);\n      var basename = path.basename(mainAppScript);\n\n      fs.readdir(dirname, function(err, files) {\n        var realBaseName = files.filter(function(filename) {\n          return filename.toLowerCase() == basename.toLowerCase();\n        })[0];\n\n        mainAppScript = path.join(dirname, realBaseName);\n        this._scriptManager.realMainAppScript = mainAppScript;\n\n        return done(null, startDirectory, mainAppScript);\n      }.bind(this));\n    }.bind(this));\n  },\n\n  _getResourceTreeForAppScript: function(target, startDirectory, mainAppScript, done) {\n    async.waterfall(\n      [\n        this._scriptStorage.findAllApplicationScripts\n          .bind(this._scriptStorage, startDirectory, mainAppScript),\n        this._createResourceTreeResponse.bind(this, target, mainAppScript)\n      ],\n      done\n    );\n  },\n\n  _createResourceTreeResponse: function(target, mainAppScript, scriptFiles, done) {\n    var resources = scriptFiles.map(function(filePath) {\n      return {\n        url: convert.v8NameToInspectorUrl(filePath),\n        type: 'Script',\n        mimeType: 'text/javascript'\n      };\n    });\n\n    done(null, {\n      frameTree: {\n        frame: {\n          id: 'nodeinspector-toplevel-frame',\n          url: convert.v8NameToInspectorUrl(mainAppScript),\n          securityOrigin: 'node-inspector',\n\n          // Front-end keeps a history of local modifications based\n          // on loaderId. Ideally we should return such id that it remains\n          // same as long as the the debugger process has the same content\n          // of scripts and that changes when a new content is loaded.\n          loaderId: target.pid,\n          _isNodeInspectorScript: true\n        },\n        resources: resources\n      }\n    });\n  },\n\n  getResourceContent: function(params, done) {\n    var scriptName = convert.inspectorUrlToV8Name(params.url,\n      this._scriptManager.normalizeName.bind(this._scriptManager));\n\n    if (scriptName === '') {\n      // When running REPL, main application file is null\n      // and node inspector returns an empty string to the front-end.\n      // However, front-end still asks for resource content.\n      // Let's return a descriptive comment then.\n      var content = '// There is no main module loaded in node.\\n' +\n        '// This is expected when you are debugging node\\'s interactive REPL console.';\n\n      return process.nextTick(\n        this._convertScriptSourceToGetResourceResponse.bind(this, content, done));\n    }\n\n    async.waterfall(\n      [\n        this._scriptStorage.load.bind(this._scriptStorage, scriptName),\n        this._convertScriptSourceToGetResourceResponse.bind(this)\n      ],\n      done\n    );\n  },\n\n  _convertScriptSourceToGetResourceResponse: function(source, done) {\n    return done(null, {\n      content: source\n    });\n  },\n\n  reload: function(params, done) {\n    // This is called when user press Cmd+R (F5?), do we want to perform an action on this?\n    done();\n  }\n});\n\nexports.PageAgent = PageAgent;\n","/home/travis/build/npmtest/node-npmtest-node-inspector/node_modules/node-inspector/lib/NetworkAgent.js":"var fs = require('fs');\nvar path = require('path');\nvar dataUri = require('strong-data-uri');\nvar inherits = require('util').inherits;\nvar EventEmitter = require('events').EventEmitter;\n\nvar injection = require.resolve('./Injections/NetworkAgent');\n\nfunction NetworkAgent(config, session) {\n  try {\n    this._noInject = config.inject === false || config.inject.network === false;\n  } catch (e) {\n    this._noInject = false;\n  }\n\n  this._debuggerClient = session.debuggerClient;\n  this._frontendClient = session.frontendClient;\n  this._injectorClient = session.injectorClient;\n\n  this._capturingEnabled = true;\n  this._dataStorage = {};\n\n  if (!this._noInject) this._injectorClient.on('inject', this._inject.bind(this));\n}\n\nNetworkAgent.prototype._inject = function() {\n  this._translateEventToFrontend(\n    'requestWillBeSent',\n    'responseReceived',\n    'dataReceived',\n    'loadingFinished',\n    'loadingFailed'\n  );\n\n  this._handleEvent('_requestWillBeSent', this._registerInDataStorage.bind(this));\n  this._handleEvent('_dataReceived', this._saveToDataStorage.bind(this));\n  this._handleEvent('_loadingFinished', this._constructRequestData.bind(this));\n  this._handleEvent('_loadingFailed', this._dumpRequestData.bind(this));\n\n  this._injectorClient.injection(\n    function(require, debug, options) {\n      require(options.injection)(require, debug, options);\n    },\n    {\n      injection: injection\n    },\n    function(error, result) {\n      this._injected = !error;\n\n      if (error) return this._frontendClient.sendLogToConsole('error', error.message || error);\n    }.bind(this)\n  );\n};\n\n/**\n * @param {...string} eventNames\n*/\nNetworkAgent.prototype._translateEventToFrontend = function(eventNames) {\n  Array.prototype.forEach.call(arguments, function(event) {\n    event = 'Network.' + event;\n    this._debuggerClient.on(event, function(message) {\n      this._frontendClient.sendEvent(event, message);\n    }.bind(this));\n  }, this);\n};\n\nNetworkAgent.prototype._handleEvent = function(event, handle) {\n  event = 'Network.' + event;\n  this._debuggerClient.on(event, handle);\n};\n\nNetworkAgent.prototype._registerInDataStorage = function(message) {\n  if (!this._capturingEnabled) return;\n\n  var requestId = message.requestId;\n  if (this._dataStorage[requestId]) {\n    // don't throw error for now\n    return;\n  }\n\n  this._dataStorage[requestId] = new ResponseData();\n};\n\nNetworkAgent.prototype._saveToDataStorage = function(message) {\n  if (!this._capturingEnabled) return;\n\n  var responseData = this._dataStorage[message.requestId];\n  if (!responseData) return;\n\n  responseData.push(message.data);\n};\n\nNetworkAgent.prototype._constructRequestData = function(message) {\n  if (!this._capturingEnabled) return;\n\n  var responseData = this._dataStorage[message.requestId];\n  if (!responseData) return;\n\n  responseData.finish();\n};\n\nNetworkAgent.prototype._dumpRequestData = function(message) {\n  if (!this._capturingEnabled) return;\n\n  var responseData = this._dataStorage[message.requestId];\n  if (!responseData) return;\n\n  responseData.dump();\n};\n\nNetworkAgent.prototype.getResponseBody = function(params, done) {\n  var responseData = this._dataStorage[params.requestId];\n\n  if (!responseData)\n    return done(new Error('There is no data for request #' + params.requestId));\n\n  var result = {\n    base64Encoded: false,\n    body: null\n  };\n\n  if (!responseData.finished) {\n    responseData.once('finish', function(data) {\n      result.body = data;\n      done(null, result);\n    });\n  } else {\n    process.nextTick(function() {\n      result.body = responseData.data;\n      done(null, result);\n    });\n  }\n};\n\nNetworkAgent.prototype._setCapturingEnabled = function(params, done) {\n  this._capturingEnabled = params.enabled;\n  done();\n};\n\nNetworkAgent.prototype._clearCapturedData = function(params, done) {\n  Object.keys(this._dataStorage).forEach(function(key) {\n    this._dataStorage[key].dispose();\n  }, this);\n  this._dataStorage = {};\n  done();\n};\n\nNetworkAgent.prototype.loadResourceForFrontend = function(params, done) {\n  if (/^data:/.test(params.url)) {\n    try {\n      done(null, {\n        statusCode: 200,\n        headers: {},\n        content: dataUri.decode(params.url).toString('ascii')\n      });\n    } catch (err) {\n      done(err);\n    }\n    return;\n  }\n\n  loadFileResource(params, done);\n};\n\nfunction loadFileResource(params, done) {\n  var match = params.url.match(/^file:\\/\\/(.*)$/);\n  if (!match) {\n    return done(\n      'URL scheme not supported by Network.loadResourceForFrontend: ' +\n        params.url);\n  }\n\n  var filePath = match[1];\n\n  if (process.platform == 'win32') {\n    // On Windows, we should receive '/C:/path/to/file'.\n    if (!/^\\/[a-zA-Z]:\\//.test(filePath)) {\n      return done('Invalid windows path: ' + filePath);\n    }\n\n    // Remove leading '/' and replace all other '/' with '\\'\n    filePath = filePath.slice(1).split('/').join(path.sep);\n  }\n\n  // ensure there are no \"..\" in the path\n  filePath = path.normalize(filePath);\n\n  fs.readFile(\n    filePath,\n    { encoding: 'utf8' },\n    function(err, content) {\n      if (err) return done(err);\n      done(null, {\n        statusCode: 200,\n        headers: {},\n        content: content\n      });\n    }\n  );\n}\n\nNetworkAgent.prototype.setUserAgentOverride = function(params, done) {\n  done(null, {});\n};\n\nfunction ResponseData(id) {\n  this.data = [];\n  this.finished = false;\n}\ninherits(ResponseData, EventEmitter);\n\nResponseData.prototype.finish = function() {\n  if (this.finished) return;\n\n  this.data = this.data.join('');\n  this.finished = true;\n  this.emit('finish', this.data);\n};\n\nResponseData.prototype.dump = function() {\n  if (this.finished) return;\n\n  this.data = '';\n  this.finished = true;\n  this.emit('finish', this.data);\n};\n\nResponseData.prototype.push = function(chunk) {\n  this.data.push(chunk);\n};\n\nResponseData.prototype.dispose = function() {\n  if (!this.finished) this.dump();\n\n  this.removeAllListeners();\n};\n\nexports.NetworkAgent = NetworkAgent;\n","/home/travis/build/npmtest/node-npmtest-node-inspector/node_modules/node-inspector/lib/ProfilerAgent.js":"var semver = require('semver');\n\nvar injection = require.resolve('./Injections/ProfilerAgent');\n/**\n * @param {{inject}} config\n * @param {DebuggerClient} debuggerClient\n * @param {InjectorClient} injectorClient\n * @param {FrontendClient} frontendClient\n*/\nfunction ProfilerAgent(config, session) {\n  try {\n    this._noInject = config.inject === false || config.inject.profiles === false;\n  } catch (e) {\n    this._noInject = false;\n  }\n\n  this._injected = false;\n  this._debuggerClient = session.debuggerClient;\n  this._injectorClient = session.injectorClient;\n  this._frontendClient = session.frontendClient;\n\n  this._translateCommandToInjection(\n    'start',\n    'stop'\n  );\n\n  if (!this._noInject) this._injectorClient.on('inject', this._inject.bind(this));\n}\n\nProfilerAgent.prototype._inject = function(injected) {\n  this._translateEventToFrontend(\n    'consoleProfileStarted',\n    'consoleProfileFinished'\n  );\n\n  this._injectorClient.injection(\n    function(require, debug, options) {\n      require(options.injection)(require, debug, options);\n    },\n    {\n      injection: injection,\n      'v8-profiler': require.resolve('v8-profiler')\n    },\n    function(error, result) {\n      this._injected = !error;\n\n      if (error) return this._frontendClient.sendLogToConsole('error', error.message || error);\n    }.bind(this)\n  );\n};\n\n/**\n * @param {...string} eventNames\n*/\nProfilerAgent.prototype._translateEventToFrontend = function(eventNames) {\n  Array.prototype.forEach.call(arguments, function(event) {\n    event = 'Profiler.' + event;\n    this._debuggerClient.on(event, function(message) {\n      this._frontendClient.sendEvent(event, message);\n    }.bind(this));\n  }, this);\n};\n\n/**\n * @param {...string} commandNames\n*/\nProfilerAgent.prototype._translateCommandToInjection = function(commandNames) {\n  Array.prototype.forEach.call(arguments, function(command) {\n    this[command] = function(params, done) {\n      this._debuggerClient.request('Profiler.' + command, params, done);\n    };\n  }, this);\n};\n\nProfilerAgent.prototype.enable = function(params, done) {\n  done();\n\n  if (this._debuggerClient.isReady) {\n    this._checkCompatibility();\n  } else {\n    this._debuggerClient.on('connect', this._checkCompatibility.bind(this));\n  }\n};\n\nProfilerAgent.prototype._checkCompatibility = function() {\n  var version = this._debuggerClient.target.nodeVersion;\n  var isCompatible = ProfilerAgent.nodeVersionIsCompatible(version);\n  if (!isCompatible) {\n    this._frontendClient.sendLogToConsole(\n      'warning',\n      'Your Node version (' + version + ') has a partial support of profiler.\\n' +\n      'The stack frames tree doesn\\'t show all stack frames due to low sampling rate.\\n' +\n      'The profiling data is incomplete and may show misleading results.\\n' +\n      'Update Node to v0.11.13 or newer to get full support.'\n    );\n  }\n};\n\nProfilerAgent.nodeVersionIsCompatible = function(version) {\n  return semver.satisfies(version, '>=0.11.13');\n};\n\nexports.ProfilerAgent = ProfilerAgent;\n","/home/travis/build/npmtest/node-npmtest-node-inspector/node_modules/node-inspector/lib/HeapProfilerAgent.js":"var convert = require('./convert');\n\nvar injection = require.resolve('./Injections/HeapProfilerAgent');\n\n/**\n * @param {{inject}} config\n * @param {DebuggerClient} debuggerClient\n * @param {InjectorClient} injectorClient\n * @param {FrontendClient} frontendClient\n * @param {HeapProfilerClient} heapProfilerClient\n*/\nfunction HeapProfilerAgent(config, session) {\n  try {\n    this._noInject = config.inject === false || config.inject.profiles === false;\n  } catch (e) {\n    this._noInject = false;\n  }\n\n  this._injected = false;\n  this._debuggerClient = session.debuggerClient;\n  this._injectorClient = session.injectorClient;\n  this._frontendClient = session.frontendClient;\n  this._heapProfilerClient = session.heapProfilerClient;\n\n  this._translateCommandToInjection(\n    'takeHeapSnapshot',\n    'getObjectByHeapObjectId',\n    'startTrackingHeapObjects',\n    'stopTrackingHeapObjects'\n  );\n\n  if (!this._noInject) {\n    this._injectorClient.on('inject', this._inject.bind(this));\n  }\n}\n\nHeapProfilerAgent.prototype._inject = function() {\n  this._translateEventToFrontend(\n    'reportHeapSnapshotProgress',\n    'addHeapSnapshotChunk',\n    'heapStatsUpdate',\n    'lastSeenObjectId'\n  );\n\n  this._injectorClient.injection(\n    function(require, debug, options) {\n      require(options.injection)(require, debug, options);\n    },\n    {\n      injection: injection,\n      'v8-profiler': require.resolve('v8-profiler')\n    },\n    function(error, result) {\n      this._injected = !error;\n\n      if (error) return this._frontendClient.sendLogToConsole('error', error.message || error);\n    }.bind(this)\n  );\n};\n\n/**\n * @param {...string} eventNames\n*/\nHeapProfilerAgent.prototype._translateEventToFrontend = function(eventNames) {\n  Array.prototype.forEach.call(arguments, function(event) {\n    event = 'HeapProfiler.' + event;\n    this._debuggerClient.on(event, function(message) {\n      this._frontendClient.sendEvent(event, message);\n    }.bind(this));\n  }, this);\n};\n\n/**\n * @param {...string} commandNames\n*/\nHeapProfilerAgent.prototype._translateCommandToInjection = function(commandNames) {\n  Array.prototype.forEach.call(arguments, function(command) {\n    this[command] = function(params, done) {\n      this._debuggerClient.request('HeapProfiler.' + command, params, function(error, result) {\n        if (command == 'getObjectByHeapObjectId' && result && result.result) {\n          this._heapProfilerClient.convertHandleToHeapHandle(result.result);\n          result.result = convert.v8ResultToInspectorResult(result.result);\n        }\n        done(error, result);\n      }.bind(this));\n    };\n  }, this);\n};\n\nexports.HeapProfilerAgent = HeapProfilerAgent;\n","/home/travis/build/npmtest/node-npmtest-node-inspector/node_modules/node-inspector/lib/HeapProfilerClient.js":"//heap:refHandle\nvar HEAP_ID_MATCHER = /^heap:(\\d+)$/;\n\nfunction HeapProfilerClient(config, session) {\n  this._debuggerClient = session.debuggerClient;\n}\n\nHeapProfilerClient.prototype.isHeapObjectId = function(objectId) {\n  return HEAP_ID_MATCHER.test(objectId);\n};\n\nHeapProfilerClient.prototype.lookupHeapObjectId = function(objectId, done) {\n  var matchedId = HEAP_ID_MATCHER.exec(objectId);\n  this._debuggerClient.request(\n    'HeapProfiler._lookupHeapObjectId',\n    {\n      objectId: matchedId[1]\n    },\n    function(error, lookupBody, lookupRefs) {\n      if (error) return done(error);\n\n      Object.keys(lookupRefs).forEach(function(key) {\n        this.convertHandleToHeapHandle(lookupRefs[key]);\n      }, this);\n      done(null, lookupBody, lookupRefs);\n    }.bind(this)\n  );\n};\n\nHeapProfilerClient.prototype.convertHandleToHeapHandle = function(ref) {\n  if (ref.handle !== undefined) {\n    ref.handle = 'heap:' + ref.handle;\n  }\n};\n\nexports.HeapProfilerClient = HeapProfilerClient;\n","/home/travis/build/npmtest/node-npmtest-node-inspector/node_modules/node-inspector/lib/InjectorClient.js":"var EventEmitter = require('events').EventEmitter,\n    inherits = require('util').inherits,\n    async = require('async'),\n    util = require('util'),\n    debug = require('debug')('node-inspector:injector');\n\n/**\n * @param {{inject}} config\n * @param {DebuggerClient} debuggerClient\n * @constructor\n */\nfunction InjectorClient(config, session) {\n  this._noInject = config.inject === false;\n  this._injected = false;\n  this._appPausedByInjector = false;\n\n  this._debuggerClient = session.debuggerClient;\n  this._frontendClient = session.frontendClient;\n  this._debuggerClient.on('close', this.close.bind(this));\n}\n\ninherits(InjectorClient, EventEmitter);\n\nObject.defineProperties(InjectorClient.prototype, {\n  /** @type {boolean} */\n  needsInject: {\n    get: function() {\n      return !this._noInject && !this._injected;\n    }\n  }\n});\n\n/**\n * @param {string} sourceLine\n * @type {boolean}\n */\nInjectorClient.prototype.tryHandleDebuggerBreak = function(sourceLine, done) {\n  return done(this._appPausedByInjector);\n};\n\n/**\n */\nInjectorClient.prototype.inject = function(cb) {\n  if (typeof cb !== 'function') {\n    cb = function(error, result) {};\n  }\n\n  var _water = [];\n\n  if (this.needsInject) {\n    _water.unshift(\n      this._injectRequire.bind(this),\n      this._inject.bind(this),\n      this._onInjection.bind(this)\n    );\n  }\n\n  if (this.needsInject && this._debuggerClient.isRunning) {\n    _water.unshift(this._pause.bind(this));\n    _water.push(this._resume.bind(this));\n  }\n\n  async.waterfall(_water, function(error) {\n    if (error) {\n      this._frontendClient.sendLogToConsole('error', error.toString());\n    }\n    cb(error);\n  }.bind(this));\n};\n\nInjectorClient.prototype._pause = function(cb) {\n  this._appPausedByInjector = true;\n  this._debuggerClient.request('suspend', {}, function() {\n    cb();\n  });\n};\n\nInjectorClient.prototype._resume = function(cb) {\n  this._debuggerClient.request('continue', undefined, function() {\n    this._appPausedByInjector = false;\n    cb();\n  }.bind(this));\n};\n\n// inject process._require before injecting others.\nInjectorClient.prototype._injectRequire = function(cb) {\n  var self = this;\n  var breakpoint;\n  var debuggerClient = this._debuggerClient;\n\n  function handleBreak(obj) {\n    if (!(breakpoint && obj.script.id === breakpoint.script_id &&\n      obj.breakpoints.indexOf(breakpoint.breakpoint) > -1)) {\n      return;\n    }\n\n    debuggerClient.removeListener('break', handleBreak);\n    debuggerClient.request('evaluate', {\n      expression: 'process._require = NativeModule.require',\n    }, function(err, res) {\n      if (err) {\n        cb(err);\n      } else {\n        debuggerClient.request('clearbreakpoint', {\n          breakpoint: breakpoint.breakpoint,\n        }, function(err) {\n          self._resume(function() {\n            cb(err);\n          });\n        });\n      }\n    });\n  }\n\n  debuggerClient.on('break', handleBreak);\n\n  debuggerClient.request('scripts', {\n    includeSource: true,\n  }, function(err, res) {\n    if (err) {\n      err.message = 'request scripts, ' + err.message;\n      return cb(err);\n    }\n    var desc;\n    for (var i = 0; i < res.length; i++) {\n      var item = res[i];\n      var name = item.name;\n      if (item.type === 'script' && (name === 'bootstrap_node.js' || name === 'node.js') ) {\n        desc = item;\n        break;\n      }\n    }\n\n    var source = desc.source.split('\\n');\n    var line = -1;\n    for(var j = 0; j < source.length; j++) {\n      if (/^NativeModule\\.require\\s*=\\s*function/.test(source[j].trim())) {\n        line = j;\n        break;\n      }\n    }\n\n    self._resume(function() {\n      debuggerClient.request('setbreakpoint', {\n        type: 'scriptId',\n        target: desc.id,\n        line: line + 1\n      }, function(err, res) {\n        if (err) {\n          err.message = 'request setbreakpoint, ' + err.message;\n          return cb(err);\n        }\n        breakpoint = res;\n        // we need to call NativeModule.require\n        // https://github.com/nodejs/node/blob/v7.8.0/lib/console.js#L95\n        debuggerClient.request('evaluate', {\n          global: true,\n          expression: 'try{console.assert();}catch(e){}',\n        });\n      });\n    });\n\n  });\n};\n\n/**\n * @param {Number} NM - handle of NativeModule object\n */\nInjectorClient.prototype._inject = function(cb) {\n  var injectorServerPath = JSON.stringify(require.resolve('./InjectorServer'));\n  var options = {\n    'v8-debug': require.resolve('v8-debug'),\n    'convert': require.resolve('./convert')\n  };\n\n  var args = {\n    global: true,\n    expression: '(function (require) {' +\n      'require(\"module\")._load(' + injectorServerPath + ')' +\n      '(' + JSON.stringify(options) + ')' +\n    '})(process._require)'\n  };\n\n  this._debuggerClient.request(\n    'evaluate',\n    args,\n    function(error) {\n      cb(error);\n    }\n  );\n};\n\n/**\n */\nInjectorClient.prototype._onInjection = function(cb) {\n  this._injected = true;\n  this.emit('inject');\n  cb();\n};\n\nInjectorClient.prototype.close = function() {\n  this._injected = false;\n  this._appPausedByInjector = false;\n  this.emit('close');\n};\n\nInjectorClient.prototype.injection = function(injection, options, callback) {\n  this._debuggerClient.request(\n    'evaluate',\n    {\n      expression: '(' + injection.toString() + ')' +\n                  '(process._require, process._debugObject, ' + JSON.stringify(options) + ')',\n      global: true\n    },\n    callback\n  );\n};\n\nmodule.exports.InjectorClient = InjectorClient;\n","/home/travis/build/npmtest/node-npmtest-node-inspector/node_modules/node-inspector/lib/InjectorServer.js":"/**\n* @param {Array} injections\n* @param {Array} options\n*/\nfunction injectorServer(options) {\n  var nextHandleId = 0;\n\n  var debug = require(options['v8-debug']);\n  var makeMirrorSerializer = debug.get('MakeMirrorSerializer');\n\n  global.process._require = require;\n  global.process._debugObject = debug;\n\n  debug.convert = require(options['convert']);\n\n  debug.serializeAndCacheMirror = function(cache, mirror, response) {\n    // Get previously cached mirror if existed\n    mirror = resolveCachedMirror(cache, mirror);\n\n    var serializer = makeMirrorSerializer(true, {\n      maxStringLength: -1\n    });\n    var body = serializer.serializeValue(mirror);\n\n    // Current serialization doesn't support internal properties refs\n    // Will be fixed after injecting InjectedScript.js\n    delete body.internalProperties;\n\n    var refs = {};\n    serializer.mirrors_.forEach(function(refMirror) {\n      refs[refMirror.handle()] = resolveCachedMirror(cache, refMirror);\n    });\n\n    Object.keys(body).forEach(function(key) {\n      var prop = body[key];\n      checkRefProperty(refs, prop);\n    });\n\n    if (response) {\n      response.refs = serializer.mirrors_.map(function(refMirror) {\n        return debug.serializeAndCacheMirror(cache, refMirror);\n      });\n    }\n\n    return body;\n  };\n\n  function resolveCachedMirror(cache, mirror) {\n    var mirrorKey = Object.keys(cache).filter(function(key) {\n      var cached = cache[key];\n\n      if (!mirror.value || !cached.value) return false;\n\n      // Special check for NaN as NaN == NaN is false.\n      if (mirror.isNumber() && isNaN(mirror.value()) &&\n          cached.isNumber() && isNaN(cached.value())) {\n        return true;\n      }\n\n      return mirror.value() === cached.value();\n    })[0];\n\n    if (mirrorKey === undefined) {\n      mirrorKey = mirror.handle_ = nextHandleId++;\n      cache[mirrorKey] = mirror;\n    }\n\n    return cache[mirrorKey];\n  }\n\n  function checkRefProperty(refs, prop) {\n    if (typeof prop != 'object') return;\n\n    if (prop.length)\n      prop.forEach(checkRefProperty.bind(null, refs));\n    else if (prop.ref !== undefined)\n      prop.ref = refs[prop.ref].handle();\n  }\n}\n\nmodule.exports = injectorServer;\n","/home/travis/build/npmtest/node-npmtest-node-inspector/node_modules/node-inspector/lib/ScriptManager.js":"var events = require('events'),\n    path = require('path'),\n    async = require('async'),\n    debug = require('debug')('node-inspector:ScriptManager'),\n    semver = require('semver'),\n    dataUri = require('strong-data-uri'),\n    pathIsAbsolute = require('path-is-absolute'),\n    convert = require('./convert.js');\n\n// see Blink inspector > ContentSearchUtils.cpp > findMagicComment()\nvar SOURCE_MAP_URL_REGEX = /\\/\\/[@#][ \\t]sourceMappingURL=[ \\t]*([^\\s'\"]*)[ \\t]*$/m;\n\n/**\n * @param {{hidden}} config\n * @param {FrontendClient} frontendClient\n * @param {DebuggerClient} debuggerClient\n * @constructor\n */\nfunction ScriptManager(config, session) {\n  config = config || {};\n  var self = Object.create(ScriptManager.prototype, {\n    _sources: { value: {}, writable: true },\n    _hidden: { value: config.hidden || [] },\n    _frontendClient: { value: session.frontendClient },\n    _debuggerClient: { value: session.debuggerClient }\n  });\n  self._debuggerClient.on('afterCompile', self._onAfterCompile.bind(self));\n  self._debuggerClient.on('compileError', self._onCompileError.bind(self));\n  return self;\n}\n\nScriptManager.prototype = Object.create(events.EventEmitter.prototype, {\n  mainAppScript: { value: null, writable: true },\n\n  realMainAppScript: { value: null, writable: true },\n\n  _onAfterCompile: {\n    value: function(event) {\n      if (!event.script) {\n        console.log(\n          'Unexpected error: debugger emitted afterCompile event' +\n            'with no script data.'\n        );\n        return;\n      }\n      this.addScript(event.script);\n    }\n  },\n\n  _onCompileError: {\n    value: function(event) {\n      var cb = function() {\n        var version = this._debuggerClient.target.nodeVersion;\n        if (semver.satisfies(version, '~0.12'))\n          // Relative to https://github.com/joyent/node/issues/25266\n          this._onAfterCompile(event);\n      }.bind(this);\n\n      if (this._debuggerClient.isReady)\n        process.nextTick(cb);\n      else\n        this._debuggerClient.once('connect', cb);\n    }\n  },\n\n  _isNodeInternal: {\n    value: function(scriptName) {\n      // node.js internal scripts have no path, just a filename\n      // regular scripts have always a full path\n      //   (i.e their name contains at least one path separator)\n      var isFullPath = /[\\/\\\\]/.test(scriptName);\n      return !isFullPath;\n    }\n  },\n\n  _listAllSources: {\n    value: function() {\n      var self = this;\n      return Object.keys(this._sources).map(function fnSelectValue(key) {\n        return self._sources[key];\n      });\n    }\n  },\n\n  isScriptHidden: {\n    /**\n     * @param {string} scriptPath.\n     * @return {boolean}\n     */\n    value: function(scriptPath) {\n      return this._hidden.some(function fnHiddenScriptMatchesPath(r) {\n        return r.test(scriptPath);\n      });\n    }\n  },\n\n  resolveScriptById: {\n    value: function(id, done) {\n      var source = this.findScriptByID(id);\n\n      if (!source) {\n        this._requireScriptFromApp(id, done);\n      } else {\n        process.nextTick(function() {\n          done(null, source);\n        });\n      }\n    }\n  },\n\n  getScriptSourceById: {\n    value: function(id, callback) {\n      this._debuggerClient.request(\n        'scripts',\n        {\n          includeSource: true,\n          types: 4,\n          ids: [id]\n        },\n        function handleScriptSourceResponse(err, result) {\n          if (err) return callback(err);\n\n          // Some modules gets unloaded (?) after they are parsed,\n          // e.g. node_modules/express/node_modules/methods/index.js\n          // V8 request 'scripts' returns an empty result in such case\n          var source = result.length > 0 ? result[0].source : undefined;\n\n          callback(null, source);\n        }\n      );\n    }\n  },\n\n  _requireScriptFromApp: {\n    value: function(id, done) {\n      // NOTE: We can step in this function only if `afterCompile` event is broken\n      // This is issue for node v0.12: https://github.com/joyent/node/issues/25266\n      this._debuggerClient.request(\n        'scripts',\n        {\n          includeSource: false,\n          filter: id\n        },\n        function(error, scripts) {\n          if (error) return done(error);\n          if (!scripts[0]) return done(null);\n\n          this.addScript(scripts[0], done);\n        }.bind(this)\n      );\n    }\n  },\n\n  findScriptIdByPath: {\n    value: function(path) {\n      return Object.keys(this._sources).filter(function(key) {\n        return this._sources[key].v8name == path;\n      }, this)[0];\n    }\n  },\n\n  findScriptByID: {\n    /**\n     * @param {string} id script id.\n     * @return {{hidden: boolean, path: string, url: string}}\n     */\n    value: function(id) {\n      return this._sources[id];\n    }\n  },\n\n  addScript: {\n    value: function(v8data, done) {\n      done = done || function() {};\n\n      var localPath = v8data.name;\n      if (this._isMainAppScript(localPath)) {\n        v8data.name = localPath = this.realMainAppScript;\n      }\n\n      var hidden = this.isScriptHidden(localPath) && localPath != this.mainAppScript;\n\n      var inspectorScriptData = this._doAddScript(v8data, hidden);\n\n      debug('addScript id: %s localPath: %s hidden? %s source? %s',\n        v8data.id, localPath, hidden, !!v8data.source);\n\n      if (hidden) return done(null, inspectorScriptData);\n\n      if (this._isNodeInternal(localPath)) {\n        this._notifyScriptParsed(inspectorScriptData);\n        done(null, inspectorScriptData);\n      } else {\n        this._getSourceMapUrl(\n          v8data.id,\n          v8data.source,\n          function onGetSourceMapUrlReturn(err, sourceMapUrl) {\n            if (err) {\n              console.log(\n                'Warning: cannot parse SourceMap URL for script %s (id %d). %s',\n                localPath,\n                v8data.id,\n                err);\n            }\n\n            debug('sourceMapUrl for script %s:%s is %s', v8data.id, localPath, sourceMapUrl);\n\n            inspectorScriptData.sourceMapURL = sourceMapUrl;\n\n            this._checkInlineSourceMap(inspectorScriptData);\n            this._notifyScriptParsed(inspectorScriptData);\n\n            done(null, inspectorScriptData);\n          }.bind(this)\n        );\n      }\n    }\n  },\n\n  _checkInlineSourceMap: {\n    value: function(inspectorScriptData) {\n      // Source maps have some issues in different libraries.\n      // If source map exposed in inline mode, we can easy fix some potential issues.\n      var sourceMapUrl = inspectorScriptData.sourceMapURL;\n      if (!sourceMapUrl) return;\n\n      var sourceMap;\n      try {\n        sourceMap = dataUri.decode(sourceMapUrl).toString();\n      } catch (err) {\n        return;\n      }\n\n      sourceMap = JSON.parse(sourceMap.toString());\n      this._checkSourceMapIssues(inspectorScriptData, sourceMap);\n      sourceMap = JSON.stringify(sourceMap);\n\n      inspectorScriptData.sourceMapURL = dataUri.encode(sourceMap, 'application/json');\n    }\n  },\n\n  _checkSourceMapIssues: {\n    value: function(inspectorScriptData, sourceMap) {\n      var scriptName = inspectorScriptData.url.replace(/^file:\\/\\//, '');\n      if (process.platform == 'win32') {\n        scriptName = scriptName.replace(/^\\//, '');\n      }\n      var scriptOrigin = path.dirname(scriptName);\n      fixAbsoluteSourcePaths();\n      fixWrongFileName();\n\n      function fixAbsoluteSourcePaths() {\n        // Documentation says what source maps can contain absolute paths,\n        // but DevTools strictly expects relative paths.\n        sourceMap.sources = sourceMap.sources.map(function(source) {\n          if (!pathIsAbsolute(source)) return source;\n\n          return path.relative(scriptOrigin, source);\n        });\n      }\n\n      function fixWrongFileName() {\n        // Documentation says nothing about file name of bundled script.\n        // So, we expect a situation, when original source and bundled script have equal name.\n        // We need to fix this case.\n        sourceMap.sources = sourceMap.sources.map(function(source) {\n          var sourceUrl = path.resolve(scriptOrigin, source).replace(/\\\\/g, '/');\n          if (sourceUrl == scriptName) source += '.source';\n\n          return source;\n        });\n      }\n    }\n  },\n\n  _notifyScriptParsed: {\n    value: function(scriptData) {\n      this._frontendClient.sendEvent(\n        'Debugger.scriptParsed',\n        scriptData\n      );\n    }\n  },\n\n  _isMainAppScript: {\n    value: function(path) {\n      if (!path || !this.mainAppScript) return false;\n      if (process.platform == 'win32')\n        return this.mainAppScript.toLowerCase() == path.replace(/\\//g, '\\\\').toLowerCase();\n      else\n        return this.mainAppScript == path;\n    }\n  },\n\n  normalizeName: {\n    value: function(name) {\n      var scriptName = name.replace(/^file:\\/\\//, '');\n      if (process.platform == 'win32') {\n        scriptName = scriptName.replace(/^\\//, '');\n      }\n      if (this._isMainAppScript(scriptName)) {\n        return convert.v8NameToInspectorUrl(this.mainAppScript);\n      }\n\n      return name;\n    }\n  },\n\n  _doAddScript: {\n    value: function(v8data, hidden) {\n      var inspectorUrl = convert.v8NameToInspectorUrl(v8data.name);\n      var inspectorScriptData = {\n        scriptId: String(v8data.id),\n        url: inspectorUrl,\n        startLine: v8data.lineOffset,\n        startColumn: v8data.columnOffset\n\n        /* Properties not set:\n         endLine: undefined,\n         endColumn: undefined,\n         isContentScript: undefined,\n         hasSourceURL: undefined,\n         */\n      };\n\n      var item = {\n        hidden: hidden,\n        v8name: v8data.name,\n        url: inspectorUrl\n      };\n\n      this._sources[inspectorScriptData.scriptId] = item;\n      return inspectorScriptData;\n    }\n  },\n\n  _getSourceMapUrl: {\n    value: function(scriptId, scriptSource, callback) {\n      var getSource;\n      if (scriptSource == null) {\n        debug('_getSourceMapUrl(%s) - fetching source from V8', scriptId);\n        getSource = this.getScriptSourceById.bind(this, scriptId);\n      } else {\n        debug('_getSourceMapUrl(%s) - using the suplied source', scriptId);\n        getSource = function(cb) { cb(null, scriptSource); };\n      }\n\n      async.waterfall(\n        [\n          getSource,\n          this._parseSourceMapUrlFromScriptSource.bind(this)\n        ],\n        callback\n      );\n    }\n  },\n\n  _parseSourceMapUrlFromScriptSource: {\n    value: function(source, callback) {\n      var match = SOURCE_MAP_URL_REGEX.exec(source);\n      callback(null, match ? match[1] : undefined);\n    }\n  },\n\n  reset: {\n    value: function() {\n      this._sources = {};\n    }\n  }\n});\n\nexports.ScriptManager = ScriptManager;\n","/home/travis/build/npmtest/node-npmtest-node-inspector/node_modules/node-inspector/lib/config.js":"var fs = require('fs'),\n    rc = require('rc'),\n    yargs = require('yargs'),\n    path = require('path'),\n    util = require('util');\n\nmodule.exports = Config;\n\nvar definitions = {\n  'help': {\n    alias: 'h',\n    description: 'Display information about avaible options.',\n    usage: {\n      '--help': '           display short list of avaible options',\n      '--help <option>': '  display quick help on <option>',\n      '--help -l': '        display full usage info'\n    },\n    _isNodeInspectorOption: true,\n    _isNodeDebugOption: true,\n    default: false\n  },\n  'version': {\n    alias: 'v',\n    type: 'boolean',\n    description: 'Display Node Inspector\\'s version.',\n    usage: '--version',\n    _isNodeInspectorOption: true,\n    _isNodeDebugOption: true,\n    default: false\n  },\n  'web-port': {\n    alias: ['port', 'p'],\n    type: 'string',\n    description: 'Port to listen on for Node Inspector\\'s web interface.',\n    usage: {\n      '--web-port 8081': '',\n      '-p 8081': ''\n    },\n    _isNodeInspectorOption: true,\n    default: '8080'\n  },\n  'web-host': {\n    type: 'string',\n    description: 'Host to listen on for Node Inspector\\'s web interface.',\n    usage: {\n      '--web-host 127.0.0.1': '',\n      '--web-host www.example.com': ''\n    },\n    _isNodeInspectorOption: true,\n    default: '0.0.0.0'\n  },\n  'debug-port': {\n    alias: 'd',\n    type: 'number',\n    description: 'Node/V8 debugger port (`node --debug={port}`).',\n    _isNodeInspectorOption: true,\n    _isNodeDebugOption: true,\n    default: 5858\n  },\n  'debug-host': {\n    type: 'string',\n    description: 'Host to run Node/V8 debugger.',\n    usage: {\n      '--debug-host 127.0.0.1': '',\n      '--debug-host www.example.com': ''\n    },\n    _isNodeInspectorOption: true,\n    default: '127.0.0.1'\n  },\n  'save-live-edit': {\n    type: 'boolean',\n    description: 'Save live edit changes to disk (update the edited files).',\n    usage: {\n      '--save-live-edit': '',\n      '--no-save-live-edit': '    disable saving live edit changes to disk'\n    },\n    _isNodeInspectorOption: true,\n    default: false\n  },\n  'preload': {\n    type: 'boolean',\n    description: 'Preload *.js files. You can disable this option to speed up the startup.',\n    usage: {\n      '--preload': '',\n      '--no-preload': '    disable preloading *.js files'\n    },\n    _isNodeInspectorOption: true,\n    default: true\n  },\n  'inject': {\n    description: 'Enable/disable injection of debugger extensions into the debugged process.\\n' +\n               '  It`s posiible to disable only part of injections using subkeys.\\n' +\n               '  Available subkeys: network, profiles, console',\n    usage: {\n      '--inject': '',\n      '--no-inject': '            disable injecting of debugger extensions',\n      '--no-inject.network': '    disable injecting of debugger network extension only\\n',\n    },\n    _isNodeInspectorOption: true,\n    default: true\n  },\n  'plugins': {\n    type: 'boolean',\n    description: 'Enable plugin system.',\n    usage: {\n      '--plugins': '',\n      '--no-plugins': '    disable plugin system'\n    },\n    _isNodeInspectorOption: true,\n    default: false\n  },\n  'plugin-path': {\n    type: 'string',\n    description: 'The path from which to load node-inspector plugins.\\n' +\n               '  Used only if the --plugins option is set to true.\\n',\n    usage: {\n      '--plugin-path $HOME/node-inspector-plugins': 'load plugins from the given path',\n    },\n    _isNodeInspectorOption: true,\n    default: ''\n  },\n  'hidden': {\n    type: 'string',\n    description: 'Array of files to hide from the UI.' +\n                ' Breakpoints in these files will be ignored.\\n' +\n               '  All paths are interpreted as regular expressions.',\n    usage: {\n      '--hidden .*\\\\.test\\\\.js$ --hidden node_modules/': 'ignore node_modules directory' +\n      ' and all `*.test.js` files'\n    },\n    _isNodeInspectorOption: true,\n    default: []\n  },\n  'stack-trace-limit': {\n    type: 'number',\n    description: 'Number of stack frames to show on a breakpoint.',\n    _isNodeInspectorOption: true,\n    default: 50\n  },\n  'ssl-key': {\n    type: 'string',\n    description: 'A file containing a valid SSL key.',\n    usage: '--ssl-key ./ssl/key.pem --ssl-cert ./ssl/cert.pem',\n    _isNodeInspectorOption: true,\n    default: ''\n  },\n  'ssl-cert': {\n    type: 'string',\n    description: 'A file containing a valid SSL certificate.',\n    usage: '--ssl-key ./ssl/key.pem --ssl-cert ./ssl/cert.pem',\n    _isNodeInspectorOption: true,\n    default: ''\n  },\n  'nodejs': {\n    type: 'string',\n    description: 'Pass NodeJS options to debugged process (`node --option={value}`).',\n    usage: '--nodejs --harmony --nodejs --random_seed=2 app',\n    _isNodeDebugOption: true,\n    default: []\n  },\n  'debug-brk': {\n    alias: 'b',\n    type: 'boolean',\n    description: 'Break on the first line (`node --debug-brk`).',\n    _isNodeDebugOption: true,\n    default: false\n  },\n  'cli': {\n    alias: 'c',\n    type: 'boolean',\n    description: 'CLI mode, do not open browser.',\n    usage: '--cli',\n    _isNodeDebugOption: true,\n    default: false\n  }\n};\n\nfunction Config(argv, NODE_DEBUG_MODE) {\n  var defaults = collectDefaultsFromDefinitions(NODE_DEBUG_MODE);\n  var parsedArgv = parseArgs(argv);\n\n  checkDeprecatedHiddenStyle(parsedArgv);\n\n  var rcConfig = rc('node-inspector', defaults, parsedArgv);\n  var config = normalizeOptions(rcConfig);\n\n  checkDeprecatedNoPreloadStyle(config);\n  checkDeprecatedWebHostStyle(config);\n\n  util._extend(this, config);\n}\n\nfunction checkDeprecatedNoPreloadStyle(config) {\n  if (config.noPreload !== undefined) {\n    // Deprecated in v0.7.3\n    console.warn('The config option `no-preload` is deprecated, use `preload` instead');\n    config.preload = config.preload || !config.noPreload;\n    delete config.noPreload;\n  }\n}\n\nfunction checkDeprecatedWebHostStyle(config) {\n  if (config.webHost === 'null' || config.webHost === null) {\n    // Deprecated in v0.8.0\n    console.warn('You use deprecated syntax for web-host option. Use 0.0.0.0 instead of null');\n    config.webHost = '0.0.0.0';\n  }\n}\n\nfunction checkDeprecatedHiddenStyle(parsedArgv) {\n  if (parsedArgv.hidden.length == 1) {\n    // Deprecated in v0.8.0\n    var isDeprecatedDefinitionStyle = false,\n        hidden;\n    try {\n      hidden = JSON.parse(parsedArgv.hidden[0]);\n      isDeprecatedDefinitionStyle = util.isArray(hidden);\n    } catch (e) {}\n\n    if (isDeprecatedDefinitionStyle) {\n      console.warn('You use deprecated syntax for hidden option.\\n' +\n                   'Use `--hidden value1 --hidden value2` instead');\n      parsedArgv.hidden = hidden;\n    }\n  }\n}\n\nConfig._collectDefaults = function(NODE_DEBUG_MODE) {\n  var dashedKeyDefaults = collectDefaultsFromDefinitions(NODE_DEBUG_MODE);\n  return normalizeOptions(dashedKeyDefaults);\n};\n\nConfig.serializeOptions = function(options, filter) {\n  filter = filter || {};\n  var result = [];\n  Object.keys(options).forEach(function(key) {\n    if (filter[key]) return;\n\n    var serializedOption = serializeOption(keyToDashedKey(key), options[key]);\n    if (serializedOption !== '')\n      result.unshift.apply(result, [].concat(serializedOption));\n  });\n  return result;\n};\n\nfunction serializeOption(key, value, parent) {\n  parent = parent ? parent + '.' : '';\n  var prefix = (key.length > 1 || parent ? '--' : '-') + parent;\n  if (value === undefined) return '';\n  if (value === true) {\n    return prefix + key;\n  } else if (value === false) {\n    return prefix + key + '=false';\n  } else if (util.isArray(value)) {\n    if (!value.length) return '';\n    return value.map(function(_value) {\n      if (util.isRegExp(_value)) _value = _value.source;\n      return prefix + key + '=' + _value;\n    });\n  } else if (value instanceof Object) {\n    return Object.keys(value).map(function(_key) {\n      return serializeOption(_key, value[_key], parent + key);\n    }).join(' ');\n  } else {\n    return prefix + key + '=' + value;\n  }\n}\n\nConfig.filterOptions = function(filterExpression, options) {\n  var filteredOptions = {};\n\n  Object.keys(options)\n    .filter(function(key) {\n      var value = options[key];\n      var dashedKey = keyToDashedKey(key);\n      var definition = definitions[dashedKey];\n      return filterExpression(key, value, definition);\n    })\n    .forEach(function(key) {\n      filteredOptions[key] = options[key];\n    });\n\n  return filteredOptions;\n};\n\nConfig.filterNodeDebugOptions = Config.filterOptions.bind(Config, function(key, value, definition) {\n  return !definition || definition && definition._isNodeInspectorOption;\n});\n\nConfig.filterDefaultValues = Config.filterOptions.bind(Config, function(key, value, definition) {\n  return !definition || definition && definition.default !== value;\n});\n\nConfig.prototype.showVersion = function() {\n  console.log('Node Inspector v' + require('../package.json').version);\n};\n\nConfig.prototype.showHelp = function(NODE_DEBUG_MODE) {\n  var cmd = getCmd();\n\n  var inspectorOptions = [];\n  var nodeDebugOptions = [];\n  Object.keys(definitions).forEach(function(key) {\n    if (definitions[key]._isNodeDebugOption && NODE_DEBUG_MODE) {\n      nodeDebugOptions.push(key);\n    } else if (definitions[key]._isNodeInspectorOption) {\n      inspectorOptions.push(key);\n    }\n  }, this);\n\n  var inspectorPart = color('green', '[node-inspector-options]');\n  var optionsPart = color('cyan', '[options]');\n  var scriptPart = color('red', '[script [script-arguments]]');\n  var configurationParts = [inspectorPart];\n  if (NODE_DEBUG_MODE) {\n    configurationParts.unshift(optionsPart);\n    configurationParts.push(scriptPart);\n  }\n\n  if (typeof this.help == 'string') {\n    //Display help for target option\n    showOptionHelp(this.help);\n  } else if (this.l) {\n    //Display options format and options usage info\n    console.log('Usage:\\n    %s %s\\n', cmd, configurationParts.join(' '));\n    if (NODE_DEBUG_MODE) {\n      nodeDebugOptions.forEach(showOptionHelp);\n    }\n    inspectorOptions.forEach(showOptionHelp);\n  } else {\n    //Display options format, options list and some help information\n    console.log(\n        'Usage:\\n    %s %s\\n', cmd, configurationParts.join(' '));\n\n    if (NODE_DEBUG_MODE) {\n      console.log(\n        'Where %s is one or more of:\\n' +\n        '    %s\\n', optionsPart, nodeDebugOptions.join('\\n    '));\n    }\n    console.log(\n        'Where %s is one or more of:\\n' +\n        '    %s\\n', inspectorPart, inspectorOptions.join('\\n    '));\n    console.log('Use:' + formatUsage(definitions.help.usage) + '\\n');\n\n    if (NODE_DEBUG_MODE) {\n      console.log(\n        'The %s argument is resolved relative to the current working\\n' +\n        'directory. If no such file exists, then env.PATH is searched.\\n',\n        color('red', '[script]'));\n      console.log(\n        'The default mode is to break on the first line of the script, to run\\n' +\n        'immediately on start use `--no-debug-brk` or press the Resume button.\\n');\n      console.log(\n        'When there is no script specified, the module in the current working\\n' +\n        'directory is loaded in the REPL session as `m`. This allows you to call\\n' +\n        'and debug arbitrary functions exported by the current module.\\n');\n    }\n\n    console.log(\n        'Configuration can be also stored in a \\'.node-inspectorrc\\' file,\\n' +\n        'see README for more details:\\n' +\n        '  https://github.com/node-inspector/node-inspector#configuration');\n  }\n};\n\nfunction getCmd() {\n  return process.env.CMD || path.basename(process.argv[1]);\n}\n\nfunction color(_color, string) {\n  var colors = util.inspect.colors;\n  return '\\u001b[' + colors[_color][0] + 'm' + string +\n         '\\u001b[' + colors[_color][1] + 'm';\n}\n\nfunction showOptionHelp(option) {\n  var info = definitions[option];\n\n  if (info) {\n    var optionLine = '--' + option;\n    if (info.alias) {\n      var aliases = [].concat(info.alias);\n      optionLine += ', ' + aliases.map(function(alias) {\n        var prefix = alias.length == 1 ? '-' : '--';\n        return prefix + alias;\n      }).join(', ');\n    }\n    console.log(color('green', optionLine));\n    console.log('  ' + info.description);\n    if (info.default !== undefined) {\n      console.log('  Default: ' + color('yellow', JSON.stringify(info.default)));\n    }\n    if (info.usage) {\n      var formattedUsage = formatUsage(info.usage);\n      console.log('  Usage:' + formattedUsage);\n    }\n    console.log();\n  } else {\n    console.error('Description for %s not found', option);\n  }\n}\n\nfunction formatUsage(usage) {\n  var formattedUsage = '';\n  var cmd = getCmd();\n  if (typeof usage == 'object') {\n    Object.keys(usage).forEach(function(key) {\n      formattedUsage += '\\n    ' + cmd + ' ' + key + ' ' + color('grey', usage[key]);\n    });\n  } else if (typeof usage == 'string') {\n    formattedUsage += '\\n    ' + cmd + ' ' + usage;\n  }\n  return formattedUsage;\n}\n\nfunction normalizeOptions(options) {\n  var normalizedOptions = {};\n\n  Object.keys(options).forEach(function(key) {\n    var camelKey = keyToCamelKey(key);\n    normalizedOptions[camelKey] = options[key];\n  });\n\n  checkHiddenOption(normalizedOptions);\n  checkSslOptions(normalizedOptions);\n\n  return normalizedOptions;\n}\n\nfunction checkHiddenOption(options) {\n  function toRegExp(string) {\n    return new RegExp(string, 'i');\n  }\n  options.hidden = [].concat(options.hidden || []).map(toRegExp);\n}\n\nfunction checkSslOptions(options) {\n  function realPath(path) {\n    if (!path) return '';\n\n    path = fs.realpathSync(path);\n    if (!fs.existsSync(path)) throw new Error('The file \"' + path + '\" does not exist');\n\n    return path;\n  }\n\n  options.sslKey = realPath(options.sslKey);\n  options.sslCert = realPath(options.sslCert);\n}\n\nfunction keyToCamelKey(key) {\n  return key.replace(/-./g, function(letter) {\n    return letter.slice(1).toUpperCase();\n  });\n}\n\nfunction keyToDashedKey(key) {\n  return key.replace(/[A-Z]/g, function(letter) {\n    return '-' + letter.toLowerCase();\n  });\n}\n\nfunction collectDefaultsFromDefinitions(NODE_DEBUG_MODE) {\n  var options = {};\n\n  Object.keys(definitions).forEach(function(key) {\n    if (util.isArray(definitions[key].default)) {\n      options[key] = definitions[key].default.slice();\n    } else {\n      options[key] = definitions[key].default;\n    }\n  });\n\n  if (NODE_DEBUG_MODE) {\n    options['web-host'] = '127.0.0.1';\n    options['debug-brk'] = true;\n  }\n\n  return options;\n}\n\nfunction collectAliasesFromDefinitions() {\n  var aliases = [];\n\n  Object.keys(definitions).forEach(function(key) {\n    if (definitions[key].alias)\n      aliases = aliases.concat(definitions[key].alias);\n  });\n\n  return aliases;\n}\n\nfunction parseArgs(argv) {\n  var argvParser = yargs.options(definitions);\n\n  function wasCustomized(key) {\n    var definition = definitions[key];\n    if (!definition) return true;\n\n    var options = [key].concat(definition.alias || []);\n\n    return argv.some(function(arg) {\n      var optionMatcher = /^(?:--no)?-+(.*?)(?:=.*)?$/;\n      arg = (optionMatcher.exec(arg) || [])[1];\n      if (arg && options.indexOf(arg) !== -1) return true;\n    });\n  }\n\n  //Preparse --nodejs options\n  var nodejsArgs = [];\n  var nodejsIndex = argv.indexOf('--nodejs');\n  while (nodejsIndex !== -1) {\n    var nodejsArg = argv.splice(nodejsIndex, 2)[1];\n    if (nodejsArg !== undefined) {\n      nodejsArgs.push(nodejsArg);\n    }\n    nodejsIndex = argv.indexOf('--nodejs');\n  }\n\n  var options = argvParser.parse(argv);\n  var script = options._[0];\n\n  if (script) {\n    // We want to pass along subarguments, but re-parse our arguments.\n    argv = argv.slice(0, argv.indexOf(script) + 1);\n    options = argvParser.parse(argv);\n  }\n\n  //filter options\n  var aliases = collectAliasesFromDefinitions();\n  Object.keys(options).forEach(function(key) {\n    if (aliases.indexOf(key) > -1) {\n      //Filter aliases\n      delete options[key];\n    } else if (options[key] instanceof Object) {\n      //Ignore array options and object options\n    } else if (/[A-Z]/.test(key)) {\n      //filter camelKey options created by yargs\n      delete options[key];\n    } else if (!wasCustomized(key)) {\n      //filter options with default values\n      delete options[key];\n    }\n  });\n\n  options['nodejs'] = nodejsArgs;\n\n  return options;\n}\n","/home/travis/build/npmtest/node-npmtest-node-inspector/node_modules/node-inspector/lib/debug-server.js":"var http = require('http'),\n    https = require('https'),\n    EventEmitter = require('events').EventEmitter,\n    inherits = require('util').inherits,\n    extend = require('util')._extend,\n    fs = require('fs'),\n    path = require('path'),\n    express = require('express'),\n    favicon = require('serve-favicon'),\n    WebSocketServer = require('ws').Server,\n    Session = require('./session'),\n    buildInspectorUrl = require('../index.js').buildInspectorUrl,\n    buildWebSocketUrl = require('../index.js').buildWebSocketUrl,\n    plugins = require('./plugins'),\n    InspectorJson = plugins.InspectorJson,\n    ProtocolJson = plugins.ProtocolJson,\n    OVERRIDES = path.join(__dirname, '../front-end-node'),\n    WEBROOT = path.join(__dirname, '../front-end');\n\nfunction debugAction(req, res) {\n  res.sendFile(path.join(WEBROOT, 'inspector.html'));\n}\n\nfunction inspectorJson(req, res) {\n  res.send(this._inspectorJson);\n}\n\nfunction emptyJson(req, res) {\n  res.send('{}');\n}\n\nfunction jsonAction(req, res) {\n  var address = this.address();\n  res.json([{\n   'description': 'Node.js app (powered by node-inspector)',\n   'devtoolsFrontendUrl': address.url,\n   'id': process.pid,\n   'title': process.title ||'',\n   'type': 'page',\n   'url': '',\n   'webSocketDebuggerUrl': address.ws\n  }]);\n}\n\nfunction jsonVersionAction(req, res) {\n  res.json({\n    'browser': 'Node ' + process.version,\n    'protocol-version': '1.1',\n    'user-agent': 'Node ' + process.version,\n    // webKit-version is a dummy value as it's used to match compatible DevTools front-ends\n    'webKit-version': '537.36 (@181352)'\n  });\n}\n\nfunction protocolJson(req, res) {\n  res.send(this._protocolJson);\n}\n\nfunction handleWebSocketConnection(socket) {\n  var debugPort = this._getDebuggerPort(socket.upgradeReq.url),\n      debugHost = this._getDebuggerHost(socket.upgradeReq.url);\n  this._createSession(debugHost, debugPort, socket);\n}\n\nfunction handleServerListening() {\n  var address = this.address();\n  if (address.isUnixSocket) fs.chmodSync(address.port, '0777');\n  this.emit('listening');\n}\n\nfunction handleServerError(err) {\n  if (err._handledByInspector) return;\n  err._handledByInspector = true;\n  this.emit('error', err);\n}\n\nfunction DebugServer() {}\n\ninherits(DebugServer, EventEmitter);\n\nDebugServer.prototype.start = function(options) {\n  this._config = extend({}, options);\n  this._isHTTPS = this._config.sslKey && this._config.sslCert ? true : false;\n\n  plugins.init(this._config);\n\n  this._inspectorJson = new InspectorJson(this._config);\n  this._protocolJson = new ProtocolJson(this._config);\n\n  var PLUGINS = plugins.CWD;\n\n  var app = express();\n  var httpServer;\n\n  if (this._isHTTPS) {\n    httpServer = https.createServer({\n      key: fs.readFileSync(this._config.sslKey, {encoding: 'utf8'}),\n      cert: fs.readFileSync(this._config.sslCert, {encoding: 'utf8'})\n    }, app);\n  } else {\n    httpServer = http.createServer(app);\n  }\n\n  this._httpServer = httpServer;\n\n  app.use(favicon(path.join(__dirname, '../front-end-node/Images/favicon.png')));\n\n  // Json handshake\n  app.get('/json', jsonAction.bind(this));\n  app.get('/json/list', jsonAction.bind(this));\n  app.get('/json/version', jsonVersionAction.bind(this));\n\n  // Dynamically generated front-end content\n  app.get('/inspector.json', inspectorJson.bind(this));\n  app.get('/protocol.json', protocolJson.bind(this));\n  app.get('/InspectorBackendCommands.js', emptyJson);\n  app.get('/SupportedCSSProperties.js', emptyJson);\n\n  // Main routing\n  app.get('/', debugAction.bind(this));\n  app.get('/debug', debugAction.bind(this));\n  app.use('/node', express.static(OVERRIDES));\n  app.use('/plugins', express.static(PLUGINS));\n  app.use(express.static(WEBROOT));\n\n  this.wsServer = new WebSocketServer({\n    server: httpServer\n  });\n  this.wsServer.on('connection', handleWebSocketConnection.bind(this));\n  this.wsServer.on('error', handleServerError.bind(this));\n\n  httpServer.on('listening', handleServerListening.bind(this));\n  httpServer.on('error', handleServerError.bind(this));\n\n  var port = this._config.webPort;\n  var isUnixSocket = !/^\\d+$/.test(port);\n  var host = isUnixSocket ? null : this._config.webHost;\n  httpServer.listen(port, host);\n  process.once('exit', function() {\n      if (isUnixSocket) fs.unlinkSync(port);\n  }.bind(this));\n};\n\nDebugServer.prototype._getDebuggerPort = function(url) {\n  return parseInt((/[\\?\\&]port=(\\d+)/.exec(url) || [null, this._config.debugPort])[1], 10);\n};\n\nDebugServer.prototype._getDebuggerHost = function(url) {\n  return (/[\\?\\&]host=([0-9.]+)/.exec(url) || [null, this._config.debugHost])[1];\n};\n\nDebugServer.prototype._getUrlFromReq = function(req) {\n  var urlParts = req.headers.host.split(':'),\n      debugPort = this._getDebuggerPort(req.url),\n      debugHost = this._getDebuggerHost(req.url);\n  return buildInspectorUrl(urlParts[0], urlParts[1], debugPort, this._isHTTPS);\n};\n\nDebugServer.prototype._createSession = function(debugHost, debugPort, wsConnection) {\n  return new Session(this._config, debugHost, debugPort, wsConnection);\n};\n\nDebugServer.prototype.close = function() {\n  if (this.wsServer) {\n    this.wsServer.close();\n    this.emit('close');\n  }\n};\n\nDebugServer.prototype.address = function() {\n  var address = this._httpServer.address();\n  var isUnixSocket = typeof address === 'string';\n  if (isUnixSocket) address = { port: address };\n\n  var config = this._config;\n  var args = [config.webHost, address.port, config.debugPort, this._isHTTPS];\n  address.url = buildInspectorUrl.apply(null, args);\n  address.ws = buildWebSocketUrl.apply(null, args);\n  address.isUnixSocket = isUnixSocket;\n  return address;\n};\n\nexports.DebugServer = DebugServer;\n","/home/travis/build/npmtest/node-npmtest-node-inspector/node_modules/node-inspector/lib/session.js":"var EventEmitter = require('events').EventEmitter,\n    inherits = require('util').inherits,\n    DebuggerClient = require('./DebuggerClient').DebuggerClient,\n    ScriptManager = require('./ScriptManager').ScriptManager,\n    FrontendClient = require('./FrontendClient').FrontendClient,\n    FrontendCommandHandler = require('./FrontendCommandHandler').FrontendCommandHandler,\n    BreakEventHandler = require('./BreakEventHandler').BreakEventHandler,\n    ConsoleClient = require('./ConsoleClient').ConsoleClient,\n    HeapProfilerClient = require('./HeapProfilerClient').HeapProfilerClient,\n    InjectorClient = require('./InjectorClient').InjectorClient;\n\nfunction Session(config, debuggerHost, debuggerPort, wsConnection) {\n  this.debuggerClient = new DebuggerClient(debuggerHost, debuggerPort);\n  this.frontendClient = new FrontendClient(wsConnection);\n  this.injectorClient = new InjectorClient(config, this);\n  this.consoleClient = new ConsoleClient(config, this);\n  this.heapProfilerClient = new HeapProfilerClient(config, this);\n  this.scriptManager = new ScriptManager(config, this);\n  this.breakEventHandler = new BreakEventHandler(config, this);\n  this.frontendCommandHandler = new FrontendCommandHandler(config, this);\n\n  this.resourceTreeResolved = false;\n  this.once('resource-tree-resolved', function() {\n    this.resourceTreeResolved = true;\n  }.bind(this));\n\n  this.frontendClient.on('close', this.close.bind(this));\n  this.debuggerClient.on('close', this._onDebuggerClientClose.bind(this));\n  this.debuggerClient.on('error', this._onDebuggerClientError.bind(this));\n\n  this._pingInterval = setInterval(function() {\n    wsConnection.ping(null, null, true);\n  }.bind(this), 1000);\n}\n\ninherits(Session, EventEmitter);\n\nSession.prototype.close = function() {\n  clearInterval(this._pingInterval);\n  if (this.debuggerClient.isConnected)\n    this.debuggerClient.close();\n  else\n    this.emit('close');\n};\n\nSession.prototype._onDebuggerClientClose = function(reason) {\n  if (this.frontendClient.isConnected)\n    this.frontendClient.sendInspectorDetached(reason);\n  this.close();\n};\n\nSession.prototype._onDebuggerClientError = function(e) {\n  var err = e.toString();\n  if (e.helpString) {\n    err += '\\n' + e.helpString;\n  }\n  this.frontendClient.sendLogToConsole('error', err);\n};\n\nmodule.exports = Session;\n","/home/travis/build/npmtest/node-npmtest-node-inspector/node_modules/node-inspector/lib/plugins.js":"var fs = require('fs'),\n    inherits = require('util').inherits,\n    path = require('path');\n\nvar THROW_CONFLICTS = true;\n\nfunction getPluginPath(config) {\n  return (config && config.pluginPath) || path.join(__dirname, '../plugins');\n}\n\nfunction PluginError(message) {\n  this.name = 'Plugin Error';\n  this.message = this.name + ':\\n' + message;\n}\ninherits(PluginError, Error);\n\nfunction findEq(collection, option, value) {\n  return collection.filter(function(item) {\n    return item[option] == value;\n  })[0];\n}\n\nfunction mergeByName(acceptor, donor, name, onConflict) {\n  if (!donor || !donor.length) return;\n\n  donor.forEach(function(note) {\n    var sameOrigNote = findEq(acceptor, name, note[name]);\n    if (sameOrigNote) {\n      onConflict(sameOrigNote, note);\n    } else {\n      acceptor.push(note);\n    }\n  }, this);\n}\n\nvar cachedPlugins = {};\n\nfunction _setMockPlugins(pluginPath, plugins) {\n  cachedPlugins[pluginPath] = plugins;\n}\n\nfunction getPlugins(config) {\n  if (!config || !config.plugins) {\n    return [];\n  }\n\n  var pluginPath = getPluginPath(config);\n  if (cachedPlugins[pluginPath])  {\n    return cachedPlugins[pluginPath];\n  }\n\n  var dirlist;\n\n  try {\n    dirlist = fs.readdirSync(pluginPath);\n  } catch (err) {\n    dirlist = [];\n  }\n\n  var plugins = [];\n\n  dirlist.reduce(function(plugins, subdir) {\n    var _path = path.resolve(pluginPath, subdir, 'manifest.json');\n    var manifest;\n\n    try {\n      manifest = require(_path);\n\n      // This excludes situation where we have two plugins with same name.\n      if (subdir !== manifest.name)\n        throw new PluginError('Plugin name in manifest.json is different from npm module name');\n    } catch (e) {\n      console.error('Corrupted manifest.json in %s plugin\\n%s\\n%s', subdir, e.message, e.stack);\n      return plugins;\n    }\n\n    validateManifest(manifest);\n    plugins.push(manifest);\n    return plugins;\n  }, plugins);\n\n  cachedPlugins[pluginPath] = plugins;\n  return plugins;\n}\n\nfunction validateManifest(manifest) {\n  manifest.session = manifest.session || {};\n  manifest.protocol = manifest.protocol || {};\n  manifest.protocol.domains = manifest.protocol.domains || [];\n}\n\nfunction InspectorJson(config) {\n  var inspectorJsonPath = path.join(__dirname, '../front-end/inspector.json'),\n      inspectorJson = JSON.parse(fs.readFileSync(inspectorJsonPath)),\n      extendedInspectorJsonPath = path.join(__dirname, '../front-end-node/inspector.json'),\n      extendedInspectorJson = JSON.parse(fs.readFileSync(extendedInspectorJsonPath));\n\n  this._config = config;\n  this._notes = inspectorJson;\n\n  this._merge(extendedInspectorJson);\n\n  if (!config.plugins) return;\n\n  var plugins = getPlugins(config);\n\n  plugins.forEach(function(plugin) {\n    var excludes = (plugin.exclude || []).map(function(name) {\n      return { name: name, type: 'exclude' };\n    });\n\n    var overrides = plugin.override || [];\n\n    var note = {\n      name: 'plugins/' + plugin.name,\n      type: plugin.type || ''\n    };\n\n    var notes = excludes.concat(overrides).concat(note);\n\n    this._merge(notes);\n  }, this);\n}\n\nInspectorJson.prototype._merge = function(toMergeNotes) {\n  var result = [];\n\n  toMergeNotes.forEach(function(note) {\n    if (note.type == 'exclude') return;\n\n    result.push(note);\n  });\n\n  this._notes.forEach(function(note) {\n    var exists = findEq(toMergeNotes, 'name', note.name);\n    if (exists) return;\n\n    result.push(note);\n  });\n\n  this._notes = result;\n};\n\nInspectorJson.prototype.toJSON = function() {\n  return this._notes;\n};\n\n\nfunction ProtocolJson(config) {\n  var protocolJsonPath = path.join(__dirname, '../tools/protocol.json'),\n      protocolJson = JSON.parse(fs.readFileSync(protocolJsonPath)),\n      extendedProtocolJsonPath = path.join(__dirname, '../front-end-node/protocol.json'),\n      extendedProtocolJson = JSON.parse(fs.readFileSync(extendedProtocolJsonPath));\n\n  this._config = config;\n  this._protocol = protocolJson;\n  this._domains = protocolJson.domains;\n  this._extendedDomains = extendedProtocolJson.domains;\n\n  if (config.plugins) {\n    var plugins = getPlugins(config);\n    // At first step we merge all plugins in one protocol.\n    // We expect what plugins doesn't have equal methods, events or types,\n    // otherwise we throw an error, because this is unsolvable situation.\n    plugins.forEach(function(plugin) {\n      this._merge(THROW_CONFLICTS, plugin.name, this._extendedDomains, plugin.protocol.domains);\n    }, this);\n  }\n\n  // At second step we merge plugins with main protocol.\n  // Plugins can override original methods, events or types,\n  // so we don't need to throw error on conflict, we only print a warning to console.\n  this._merge(!THROW_CONFLICTS, '', this._domains, this._extendedDomains);\n}\n\nProtocolJson.prototype._merge = function(throwConflicts, pluginName, origDomains, toMergeDomains) {\n  if (!toMergeDomains.length) return;\n\n  var uniqueName = 'domain',\n      state = {\n        throwConflicts: throwConflicts,\n        plugin: pluginName\n      };\n\n  mergeByName(\n    origDomains,\n    toMergeDomains,\n    uniqueName,\n    this._onDomainConflict.bind(this, state));\n};\n\nProtocolJson.prototype._onDomainConflict = function(state, origDomain, toMergeDomain) {\n  state.domain = toMergeDomain.domain;\n\n  ['commands', 'events', 'types'].forEach(function(section) {\n    // TODO(3y3): types are unique for protocol, not for domain.\n    // We need to register types cache and search in it for conflicts.\n    var uniqueName = section == 'types' ? 'id' : 'name',\n        origSection = origDomain[section],\n        toMergeSection = toMergeDomain[section];\n\n    if (!toMergeSection || !toMergeSection.length)\n      return;\n\n    if (!origSection || !origSection.length) {\n      origDomain[section] = toMergeSection;\n      return;\n    }\n\n    state.section = section;\n    state.uname = uniqueName;\n\n    mergeByName(\n      origSection,\n      toMergeSection,\n      uniqueName,\n      this._onItemConflict.bind(this, state));\n  }, this);\n};\n\nProtocolJson.prototype._onItemConflict = function(state, origItem, toMergeItem) {\n  if (state.throwConflicts) {\n    throw new PluginError(\n      'Unresolved conflict in ' + state.section + ' section of `' + state.plugin + '` plugin: ' +\n      'item with ' + state.uname + ' `' + toMergeItem[state.uname] + '` already exists.');\n  } else {\n    console.warn(\n      'Item with ' + state.uname + ' `' + toMergeItem[state.uname] + '`' +\n      ' in ' + state.section + ' section' +\n      ' of ' + state.domain + ' domain' +\n      ' was owerriden.');\n  }\n};\n\nProtocolJson.prototype.toJSON = function() {\n  return this._protocol;\n};\n\nfunction init(config) {\n  module.exports.CWD = getPluginPath(config);\n}\n\nmodule.exports = {\n  _setMockPlugins: _setMockPlugins,\n  getPluginPath: getPluginPath,\n  getPlugins: getPlugins,\n  validateManifest: validateManifest,\n  PluginError: PluginError,\n  InspectorJson: InspectorJson,\n  ProtocolJson: ProtocolJson,\n  init: init\n};\n"}